["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/mochikit/async/deferred.js"],"~:js","goog.provide(\"goog.async.Deferred\");\ngoog.provide(\"goog.async.Deferred.AlreadyCalledError\");\ngoog.provide(\"goog.async.Deferred.CanceledError\");\ngoog.require(\"goog.Promise\");\ngoog.require(\"goog.Thenable\");\ngoog.require(\"goog.array\");\ngoog.require(\"goog.asserts\");\ngoog.require(\"goog.debug.Error\");\n/**\n @constructor\n @implements {goog.Thenable<VALUE>}\n @param {Function=} opt_onCancelFunction\n @param {Object=} opt_defaultScope\n @template VALUE\n */\ngoog.async.Deferred = function(opt_onCancelFunction, opt_defaultScope) {\n  /** @private @type {!Array<!Array>} */ this.sequence_ = [];\n  /** @private @type {(Function|undefined)} */ this.onCancelFunction_ = opt_onCancelFunction;\n  /** @private @type {Object} */ this.defaultScope_ = opt_defaultScope || null;\n  /** @private @type {boolean} */ this.fired_ = false;\n  /** @private @type {boolean} */ this.hadError_ = false;\n  /** @private @type {*} */ this.result_ = undefined;\n  /** @private @type {boolean} */ this.blocked_ = false;\n  /** @private @type {boolean} */ this.blocking_ = false;\n  /** @private @type {boolean} */ this.silentlyCanceled_ = false;\n  /** @private @type {number} */ this.unhandledErrorId_ = 0;\n  /** @private @type {?goog.async.Deferred} */ this.parent_ = null;\n  /** @private @type {number} */ this.branches_ = 0;\n  if (goog.async.Deferred.LONG_STACK_TRACES) {\n    /** @private @type {?string} */ this.constructorStack_ = null;\n    if (Error.captureStackTrace) {\n      var target = {stack:\"\"};\n      Error.captureStackTrace(target, goog.async.Deferred);\n      if (typeof target.stack == \"string\") {\n        this.constructorStack_ = target.stack.replace(/^[^\\n]*\\n/, \"\");\n      }\n    }\n  }\n};\n/** @define {boolean} */ goog.define(\"goog.async.Deferred.STRICT_ERRORS\", false);\n/** @define {boolean} */ goog.define(\"goog.async.Deferred.LONG_STACK_TRACES\", false);\n/**\n @param {boolean=} opt_deepCancel\n */\ngoog.async.Deferred.prototype.cancel = function(opt_deepCancel) {\n  if (!this.hasFired()) {\n    if (this.parent_) {\n      var parent = this.parent_;\n      delete this.parent_;\n      if (opt_deepCancel) {\n        parent.cancel(opt_deepCancel);\n      } else {\n        parent.branchCancel_();\n      }\n    }\n    if (this.onCancelFunction_) {\n      this.onCancelFunction_.call(this.defaultScope_, this);\n    } else {\n      this.silentlyCanceled_ = true;\n    }\n    if (!this.hasFired()) {\n      this.errback(new goog.async.Deferred.CanceledError(this));\n    }\n  } else {\n    if (this.result_ instanceof goog.async.Deferred) {\n      this.result_.cancel();\n    }\n  }\n};\n/** @private */ goog.async.Deferred.prototype.branchCancel_ = function() {\n  this.branches_--;\n  if (this.branches_ <= 0) {\n    this.cancel();\n  }\n};\n/**\n @private\n @param {boolean} isSuccess\n @param {*} res\n */\ngoog.async.Deferred.prototype.continue_ = function(isSuccess, res) {\n  this.blocked_ = false;\n  this.updateResult_(isSuccess, res);\n};\n/**\n @private\n @param {boolean} isSuccess\n @param {*} res\n */\ngoog.async.Deferred.prototype.updateResult_ = function(isSuccess, res) {\n  this.fired_ = true;\n  this.result_ = res;\n  this.hadError_ = !isSuccess;\n  this.fire_();\n};\n/** @private @throws {Error} */ goog.async.Deferred.prototype.check_ = function() {\n  if (this.hasFired()) {\n    if (!this.silentlyCanceled_) {\n      throw new goog.async.Deferred.AlreadyCalledError(this);\n    }\n    this.silentlyCanceled_ = false;\n  }\n};\n/**\n @param {VALUE=} opt_result\n */\ngoog.async.Deferred.prototype.callback = function(opt_result) {\n  this.check_();\n  this.assertNotDeferred_(opt_result);\n  this.updateResult_(true, opt_result);\n};\n/**\n @param {*=} opt_result\n */\ngoog.async.Deferred.prototype.errback = function(opt_result) {\n  this.check_();\n  this.assertNotDeferred_(opt_result);\n  this.makeStackTraceLong_(opt_result);\n  this.updateResult_(false, opt_result);\n};\n/**\n @private\n @param {*} error\n */\ngoog.async.Deferred.prototype.makeStackTraceLong_ = function(error) {\n  if (!goog.async.Deferred.LONG_STACK_TRACES) {\n    return;\n  }\n  if (this.constructorStack_ && goog.isObject(error) && error.stack && /^[^\\n]+(\\n   [^\\n]+)+/.test(error.stack)) {\n    error.stack = error.stack + \"\\nDEFERRED OPERATION:\\n\" + this.constructorStack_;\n  }\n};\n/**\n @private\n @param {*} obj\n @throws {Error}\n */\ngoog.async.Deferred.prototype.assertNotDeferred_ = function(obj) {\n  goog.asserts.assert(!(obj instanceof goog.async.Deferred), \"An execution sequence may not be initiated with a blocking Deferred.\");\n};\n/**\n @param {function(this:T,VALUE):?} cb\n @param {T=} opt_scope\n @return {!goog.async.Deferred}\n @template T\n */\ngoog.async.Deferred.prototype.addCallback = function(cb, opt_scope) {\n  return this.addCallbacks(cb, null, opt_scope);\n};\n/**\n @param {function(this:T,?):?} eb\n @param {T=} opt_scope\n @return {!goog.async.Deferred<VALUE>}\n @template T\n */\ngoog.async.Deferred.prototype.addErrback = function(eb, opt_scope) {\n  return this.addCallbacks(null, eb, opt_scope);\n};\n/**\n @param {function(this:T,?):?} f\n @param {T=} opt_scope\n @return {!goog.async.Deferred}\n @template T\n */\ngoog.async.Deferred.prototype.addBoth = function(f, opt_scope) {\n  return this.addCallbacks(f, f, opt_scope);\n};\n/**\n @param {function(this:T,?):?} f\n @param {T=} opt_scope\n @return {!goog.async.Deferred<VALUE>}\n @template T\n */\ngoog.async.Deferred.prototype.addFinally = function(f, opt_scope) {\n  return this.addCallbacks(f, function(err) {\n    var result = f.call(/** @type {?} */ (this), err);\n    if (!goog.isDef(result)) {\n      throw err;\n    }\n    return result;\n  }, opt_scope);\n};\n/**\n @param {?function(this:T,VALUE):?} cb\n @param {?function(this:T,?):?} eb\n @param {T=} opt_scope\n @return {!goog.async.Deferred}\n @template T\n */\ngoog.async.Deferred.prototype.addCallbacks = function(cb, eb, opt_scope) {\n  goog.asserts.assert(!this.blocking_, \"Blocking Deferreds can not be re-used\");\n  this.sequence_.push([cb, eb, opt_scope]);\n  if (this.hasFired()) {\n    this.fire_();\n  }\n  return this;\n};\n/** @override */ goog.async.Deferred.prototype.then = function(opt_onFulfilled, opt_onRejected, opt_context) {\n  var resolve, reject;\n  var promise = new goog.Promise(function(res, rej) {\n    resolve = res;\n    reject = rej;\n  });\n  this.addCallbacks(resolve, function(reason) {\n    if (reason instanceof goog.async.Deferred.CanceledError) {\n      promise.cancel();\n    } else {\n      reject(reason);\n    }\n  });\n  return promise.then(opt_onFulfilled, opt_onRejected, opt_context);\n};\ngoog.Thenable.addImplementation(goog.async.Deferred);\n/**\n @param {!goog.async.Deferred} otherDeferred\n @return {!goog.async.Deferred}\n */\ngoog.async.Deferred.prototype.chainDeferred = function(otherDeferred) {\n  this.addCallbacks(otherDeferred.callback, otherDeferred.errback, otherDeferred);\n  return this;\n};\n/**\n @param {(!goog.async.Deferred|!goog.Thenable)} otherDeferred\n @return {!goog.async.Deferred}\n */\ngoog.async.Deferred.prototype.awaitDeferred = function(otherDeferred) {\n  if (!(otherDeferred instanceof goog.async.Deferred)) {\n    return this.addCallback(function() {\n      return otherDeferred;\n    });\n  }\n  return this.addCallback(goog.bind(otherDeferred.branch, otherDeferred));\n};\n/**\n @param {boolean=} opt_propagateCancel\n @return {!goog.async.Deferred<VALUE>}\n */\ngoog.async.Deferred.prototype.branch = function(opt_propagateCancel) {\n  var d = new goog.async.Deferred;\n  this.chainDeferred(d);\n  if (opt_propagateCancel) {\n    d.parent_ = this;\n    this.branches_++;\n  }\n  return d;\n};\n/**\n @return {boolean}\n */\ngoog.async.Deferred.prototype.hasFired = function() {\n  return this.fired_;\n};\n/**\n @protected\n @param {*} res\n @return {boolean}\n */\ngoog.async.Deferred.prototype.isError = function(res) {\n  return res instanceof Error;\n};\n/**\n @private\n @return {boolean}\n */\ngoog.async.Deferred.prototype.hasErrback_ = function() {\n  return goog.array.some(this.sequence_, function(sequenceRow) {\n    return goog.isFunction(sequenceRow[1]);\n  });\n};\n/** @private */ goog.async.Deferred.prototype.fire_ = function() {\n  if (this.unhandledErrorId_ && this.hasFired() && this.hasErrback_()) {\n    goog.async.Deferred.unscheduleError_(this.unhandledErrorId_);\n    this.unhandledErrorId_ = 0;\n  }\n  if (this.parent_) {\n    this.parent_.branches_--;\n    delete this.parent_;\n  }\n  var res = this.result_;\n  var unhandledException = false;\n  var isNewlyBlocked = false;\n  while (this.sequence_.length && !this.blocked_) {\n    var sequenceEntry = this.sequence_.shift();\n    var callback = sequenceEntry[0];\n    var errback = sequenceEntry[1];\n    var scope = sequenceEntry[2];\n    var f = this.hadError_ ? errback : callback;\n    if (f) {\n      try {\n        var ret = f.call(scope || this.defaultScope_, res);\n        if (goog.isDef(ret)) {\n          this.hadError_ = this.hadError_ && (ret == res || this.isError(ret));\n          this.result_ = res = ret;\n        }\n        if (goog.Thenable.isImplementedBy(res) || typeof goog.global[\"Promise\"] === \"function\" && res instanceof goog.global[\"Promise\"]) {\n          isNewlyBlocked = true;\n          this.blocked_ = true;\n        }\n      } catch (ex) {\n        res = ex;\n        this.hadError_ = true;\n        this.makeStackTraceLong_(res);\n        if (!this.hasErrback_()) {\n          unhandledException = true;\n        }\n      }\n    }\n  }\n  this.result_ = res;\n  if (isNewlyBlocked) {\n    var onCallback = goog.bind(this.continue_, this, true);\n    var onErrback = goog.bind(this.continue_, this, false);\n    if (res instanceof goog.async.Deferred) {\n      res.addCallbacks(onCallback, onErrback);\n      res.blocking_ = true;\n    } else {\n      /** @type {!IThenable} */ (res).then(onCallback, onErrback);\n    }\n  } else {\n    if (goog.async.Deferred.STRICT_ERRORS && this.isError(res) && !(res instanceof goog.async.Deferred.CanceledError)) {\n      this.hadError_ = true;\n      unhandledException = true;\n    }\n  }\n  if (unhandledException) {\n    this.unhandledErrorId_ = goog.async.Deferred.scheduleError_(res);\n  }\n};\n/**\n @param {*=} opt_result\n @return {!goog.async.Deferred}\n */\ngoog.async.Deferred.succeed = function(opt_result) {\n  var d = new goog.async.Deferred;\n  d.callback(opt_result);\n  return d;\n};\n/**\n @param {!IThenable<T>} promise\n @return {!goog.async.Deferred<T>}\n @template T\n */\ngoog.async.Deferred.fromPromise = function(promise) {\n  var d = new goog.async.Deferred;\n  promise.then(function(value) {\n    d.callback(value);\n  }, function(error) {\n    d.errback(error);\n  });\n  return d;\n};\n/**\n @param {*} res\n @return {!goog.async.Deferred}\n */\ngoog.async.Deferred.fail = function(res) {\n  var d = new goog.async.Deferred;\n  d.errback(res);\n  return d;\n};\n/**\n @return {!goog.async.Deferred}\n */\ngoog.async.Deferred.canceled = function() {\n  var d = new goog.async.Deferred;\n  d.cancel();\n  return d;\n};\n/**\n @param {*} value\n @param {function(this:T,?):?} callback\n @param {T=} opt_scope\n @return {!goog.async.Deferred}\n @template T\n */\ngoog.async.Deferred.when = function(value, callback, opt_scope) {\n  if (value instanceof goog.async.Deferred) {\n    return value.branch(true).addCallback(callback, opt_scope);\n  } else {\n    return goog.async.Deferred.succeed(value).addCallback(callback, opt_scope);\n  }\n};\n/**\n @constructor\n @extends {goog.debug.Error}\n @param {!goog.async.Deferred} deferred\n */\ngoog.async.Deferred.AlreadyCalledError = function(deferred) {\n  goog.debug.Error.call(this);\n  /** @type {goog.async.Deferred} */ this.deferred = deferred;\n};\ngoog.inherits(goog.async.Deferred.AlreadyCalledError, goog.debug.Error);\n/** @override */ goog.async.Deferred.AlreadyCalledError.prototype.message = \"Deferred has already fired\";\n/** @override */ goog.async.Deferred.AlreadyCalledError.prototype.name = \"AlreadyCalledError\";\n/**\n @constructor\n @extends {goog.debug.Error}\n @param {!goog.async.Deferred} deferred\n */\ngoog.async.Deferred.CanceledError = function(deferred) {\n  goog.debug.Error.call(this);\n  /** @type {goog.async.Deferred} */ this.deferred = deferred;\n};\ngoog.inherits(goog.async.Deferred.CanceledError, goog.debug.Error);\n/** @override */ goog.async.Deferred.CanceledError.prototype.message = \"Deferred was canceled\";\n/** @override */ goog.async.Deferred.CanceledError.prototype.name = \"CanceledError\";\n/**\n @private\n @final\n @struct\n @constructor\n @param {*} error\n */\ngoog.async.Deferred.Error_ = function(error) {\n  /** @private @const @type {number} */ this.id_ = goog.global.setTimeout(goog.bind(this.throwError, this), 0);\n  /** @private @const @type {*} */ this.error_ = error;\n};\ngoog.async.Deferred.Error_.prototype.throwError = function() {\n  goog.asserts.assert(goog.async.Deferred.errorMap_[this.id_], \"Cannot throw an error that is not scheduled.\");\n  delete goog.async.Deferred.errorMap_[this.id_];\n  throw this.error_;\n};\ngoog.async.Deferred.Error_.prototype.resetTimer = function() {\n  goog.global.clearTimeout(this.id_);\n};\n/** @private @type {!Object<(number|string),goog.async.Deferred.Error_>} */ goog.async.Deferred.errorMap_ = {};\n/**\n @private\n @param {*} error\n @return {number}\n */\ngoog.async.Deferred.scheduleError_ = function(error) {\n  var deferredError = new goog.async.Deferred.Error_(error);\n  goog.async.Deferred.errorMap_[deferredError.id_] = deferredError;\n  return deferredError.id_;\n};\n/**\n @private\n @param {number} id\n */\ngoog.async.Deferred.unscheduleError_ = function(id) {\n  var error = goog.async.Deferred.errorMap_[id];\n  if (error) {\n    error.resetTimer();\n    delete goog.async.Deferred.errorMap_[id];\n  }\n};\ngoog.async.Deferred.assertNoErrors = function() {\n  var map = goog.async.Deferred.errorMap_;\n  for (var key in map) {\n    var error = map[key];\n    error.resetTimer();\n    error.throwError();\n  }\n};\n","~:source","// Copyright 2007 Bob Ippolito. All Rights Reserved.\n// Modifications Copyright 2009 The Closure Library Authors. All Rights\n// Reserved.\n\n/**\n * @license Portions of this code are from MochiKit, received by\n * The Closure Authors under the MIT license. All other code is Copyright\n * 2005-2009 The Closure Authors. All Rights Reserved.\n */\n\n/**\n * @fileoverview Classes for tracking asynchronous operations and handling the\n * results. The Deferred object here is patterned after the Deferred object in\n * the Twisted python networking framework.\n *\n * See: http://twistedmatrix.com/projects/core/documentation/howto/defer.html\n *\n * Based on the Dojo code which in turn is based on the MochiKit code.\n *\n * @author arv@google.com (Erik Arvidsson)\n * @author brenneman@google.com (Shawn Brenneman)\n */\n\ngoog.provide('goog.async.Deferred');\ngoog.provide('goog.async.Deferred.AlreadyCalledError');\ngoog.provide('goog.async.Deferred.CanceledError');\n\ngoog.require('goog.Promise');\ngoog.require('goog.Thenable');\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.debug.Error');\n\n\n\n/**\n * A Deferred represents the result of an asynchronous operation. A Deferred\n * instance has no result when it is created, and is \"fired\" (given an initial\n * result) by calling `callback` or `errback`.\n *\n * Once fired, the result is passed through a sequence of callback functions\n * registered with `addCallback` or `addErrback`. The functions may\n * mutate the result before it is passed to the next function in the sequence.\n *\n * Callbacks and errbacks may be added at any time, including after the Deferred\n * has been \"fired\". If there are no pending actions in the execution sequence\n * of a fired Deferred, any new callback functions will be called with the last\n * computed result. Adding a callback function is the only way to access the\n * result of the Deferred.\n *\n * If a Deferred operation is canceled, an optional user-provided cancellation\n * function is invoked which may perform any special cleanup, followed by firing\n * the Deferred's errback sequence with a `CanceledError`. If the\n * Deferred has already fired, cancellation is ignored.\n *\n * Deferreds may be templated to a specific type they produce using generics\n * with syntax such as:\n *\n *    /** @type {goog.async.Deferred<string>} *\\\n *    var d = new goog.async.Deferred();\n *    // Compiler can infer that foo is a string.\n *    d.addCallback(function(foo) {...});\n *    d.callback('string');  // Checked to be passed a string\n *\n * Since deferreds are often used to produce different values across a chain,\n * the type information is not propagated across chains, but rather only\n * associated with specifically cast objects.\n *\n * @param {Function=} opt_onCancelFunction A function that will be called if the\n *     Deferred is canceled. If provided, this function runs before the\n *     Deferred is fired with a `CanceledError`.\n * @param {Object=} opt_defaultScope The default object context to call\n *     callbacks and errbacks in.\n * @constructor\n * @implements {goog.Thenable<VALUE>}\n * @template VALUE\n */\ngoog.async.Deferred = function(opt_onCancelFunction, opt_defaultScope) {\n  /**\n   * Entries in the sequence are arrays containing a callback, an errback, and\n   * an optional scope. The callback or errback in an entry may be null.\n   * @type {!Array<!Array>}\n   * @private\n   */\n  this.sequence_ = [];\n\n  /**\n   * Optional function that will be called if the Deferred is canceled.\n   * @type {Function|undefined}\n   * @private\n   */\n  this.onCancelFunction_ = opt_onCancelFunction;\n\n  /**\n   * The default scope to execute callbacks and errbacks in.\n   * @type {Object}\n   * @private\n   */\n  this.defaultScope_ = opt_defaultScope || null;\n\n  /**\n   * Whether the Deferred has been fired.\n   * @type {boolean}\n   * @private\n   */\n  this.fired_ = false;\n\n  /**\n   * Whether the last result in the execution sequence was an error.\n   * @type {boolean}\n   * @private\n   */\n  this.hadError_ = false;\n\n  /**\n   * The current Deferred result, updated as callbacks and errbacks are\n   * executed.\n   * @type {*}\n   * @private\n   */\n  this.result_ = undefined;\n\n  /**\n   * Whether the Deferred is blocked waiting on another Deferred to fire. If a\n   * callback or errback returns a Deferred as a result, the execution sequence\n   * is blocked until that Deferred result becomes available.\n   * @type {boolean}\n   * @private\n   */\n  this.blocked_ = false;\n\n  /**\n   * Whether this Deferred is blocking execution of another Deferred. If this\n   * instance was returned as a result in another Deferred's execution\n   * sequence,that other Deferred becomes blocked until this instance's\n   * execution sequence completes. No additional callbacks may be added to a\n   * Deferred once it is blocking another instance.\n   * @type {boolean}\n   * @private\n   */\n  this.blocking_ = false;\n\n  /**\n   * Whether the Deferred has been canceled without having a custom cancel\n   * function.\n   * @type {boolean}\n   * @private\n   */\n  this.silentlyCanceled_ = false;\n\n  /**\n   * If an error is thrown during Deferred execution with no errback to catch\n   * it, the error is rethrown after a timeout. Reporting the error after a\n   * timeout allows execution to continue in the calling context (empty when\n   * no error is scheduled).\n   * @type {number}\n   * @private\n   */\n  this.unhandledErrorId_ = 0;\n\n  /**\n   * If this Deferred was created by branch(), this will be the \"parent\"\n   * Deferred.\n   * @type {?goog.async.Deferred}\n   * @private\n   */\n  this.parent_ = null;\n\n  /**\n   * The number of Deferred objects that have been branched off this one. This\n   * will be decremented whenever a branch is fired or canceled.\n   * @type {number}\n   * @private\n   */\n  this.branches_ = 0;\n\n  if (goog.async.Deferred.LONG_STACK_TRACES) {\n    /**\n     * Holds the stack trace at time of deferred creation if the JS engine\n     * provides the Error.captureStackTrace API.\n     * @private {?string}\n     */\n    this.constructorStack_ = null;\n    if (Error.captureStackTrace) {\n      var target = { stack: '' };\n      Error.captureStackTrace(target, goog.async.Deferred);\n      // Check if Error.captureStackTrace worked. It fails in gjstest.\n      if (typeof target.stack == 'string') {\n        // Remove first line and force stringify to prevent memory leak due to\n        // holding on to actual stack frames.\n        this.constructorStack_ = target.stack.replace(/^[^\\n]*\\n/, '');\n      }\n    }\n  }\n};\n\n\n/**\n * @define {boolean} Whether unhandled errors should always get rethrown to the\n * global scope. Defaults to false.\n */\ngoog.define('goog.async.Deferred.STRICT_ERRORS', false);\n\n\n/**\n * @define {boolean} Whether to attempt to make stack traces long.  Defaults to\n * false.\n */\ngoog.define('goog.async.Deferred.LONG_STACK_TRACES', false);\n\n\n/**\n * Cancels a Deferred that has not yet been fired, or is blocked on another\n * deferred operation. If this Deferred is waiting for a blocking Deferred to\n * fire, the blocking Deferred will also be canceled.\n *\n * If this Deferred was created by calling branch() on a parent Deferred with\n * opt_propagateCancel set to true, the parent may also be canceled. If\n * opt_deepCancel is set, cancel() will be called on the parent (as well as any\n * other ancestors if the parent is also a branch). If one or more branches were\n * created with opt_propagateCancel set to true, the parent will be canceled if\n * cancel() is called on all of those branches.\n *\n * @param {boolean=} opt_deepCancel If true, cancels this Deferred's parent even\n *     if cancel() hasn't been called on some of the parent's branches. Has no\n *     effect on a branch without opt_propagateCancel set to true.\n */\ngoog.async.Deferred.prototype.cancel = function(opt_deepCancel) {\n  if (!this.hasFired()) {\n    if (this.parent_) {\n      // Get rid of the parent reference before potentially running the parent's\n      // canceler function to ensure that this cancellation isn't\n      // double-counted.\n      var parent = this.parent_;\n      delete this.parent_;\n      if (opt_deepCancel) {\n        parent.cancel(opt_deepCancel);\n      } else {\n        parent.branchCancel_();\n      }\n    }\n\n    if (this.onCancelFunction_) {\n      // Call in user-specified scope.\n      this.onCancelFunction_.call(this.defaultScope_, this);\n    } else {\n      this.silentlyCanceled_ = true;\n    }\n    if (!this.hasFired()) {\n      this.errback(new goog.async.Deferred.CanceledError(this));\n    }\n  } else if (this.result_ instanceof goog.async.Deferred) {\n    this.result_.cancel();\n  }\n};\n\n\n/**\n * Handle a single branch being canceled. Once all branches are canceled, this\n * Deferred will be canceled as well.\n *\n * @private\n */\ngoog.async.Deferred.prototype.branchCancel_ = function() {\n  this.branches_--;\n  if (this.branches_ <= 0) {\n    this.cancel();\n  }\n};\n\n\n/**\n * Called after a blocking Deferred fires. Unblocks this Deferred and resumes\n * its execution sequence.\n *\n * @param {boolean} isSuccess Whether the result is a success or an error.\n * @param {*} res The result of the blocking Deferred.\n * @private\n */\ngoog.async.Deferred.prototype.continue_ = function(isSuccess, res) {\n  this.blocked_ = false;\n  this.updateResult_(isSuccess, res);\n};\n\n\n/**\n * Updates the current result based on the success or failure of the last action\n * in the execution sequence.\n *\n * @param {boolean} isSuccess Whether the new result is a success or an error.\n * @param {*} res The result.\n * @private\n */\ngoog.async.Deferred.prototype.updateResult_ = function(isSuccess, res) {\n  this.fired_ = true;\n  this.result_ = res;\n  this.hadError_ = !isSuccess;\n  this.fire_();\n};\n\n\n/**\n * Verifies that the Deferred has not yet been fired.\n *\n * @private\n * @throws {Error} If this has already been fired.\n */\ngoog.async.Deferred.prototype.check_ = function() {\n  if (this.hasFired()) {\n    if (!this.silentlyCanceled_) {\n      throw new goog.async.Deferred.AlreadyCalledError(this);\n    }\n    this.silentlyCanceled_ = false;\n  }\n};\n\n\n/**\n * Fire the execution sequence for this Deferred by passing the starting result\n * to the first registered callback.\n * @param {VALUE=} opt_result The starting result.\n */\ngoog.async.Deferred.prototype.callback = function(opt_result) {\n  this.check_();\n  this.assertNotDeferred_(opt_result);\n  this.updateResult_(true /* isSuccess */, opt_result);\n};\n\n\n/**\n * Fire the execution sequence for this Deferred by passing the starting error\n * result to the first registered errback.\n * @param {*=} opt_result The starting error.\n */\ngoog.async.Deferred.prototype.errback = function(opt_result) {\n  this.check_();\n  this.assertNotDeferred_(opt_result);\n  this.makeStackTraceLong_(opt_result);\n  this.updateResult_(false /* isSuccess */, opt_result);\n};\n\n\n/**\n * Attempt to make the error's stack trace be long in that it contains the\n * stack trace from the point where the deferred was created on top of the\n * current stack trace to give additional context.\n * @param {*} error\n * @private\n */\ngoog.async.Deferred.prototype.makeStackTraceLong_ = function(error) {\n  if (!goog.async.Deferred.LONG_STACK_TRACES) {\n    return;\n  }\n  if (this.constructorStack_ && goog.isObject(error) && error.stack &&\n      // Stack looks like it was system generated. See\n      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n      (/^[^\\n]+(\\n   [^\\n]+)+/).test(error.stack)) {\n    error.stack = error.stack + '\\nDEFERRED OPERATION:\\n' +\n        this.constructorStack_;\n  }\n};\n\n\n/**\n * Asserts that an object is not a Deferred.\n * @param {*} obj The object to test.\n * @throws {Error} Throws an exception if the object is a Deferred.\n * @private\n */\ngoog.async.Deferred.prototype.assertNotDeferred_ = function(obj) {\n  goog.asserts.assert(\n      !(obj instanceof goog.async.Deferred),\n      'An execution sequence may not be initiated with a blocking Deferred.');\n};\n\n\n/**\n * Register a callback function to be called with a successful result. If no\n * value is returned by the callback function, the result value is unchanged. If\n * a new value is returned, it becomes the Deferred result and will be passed to\n * the next callback in the execution sequence.\n *\n * If the function throws an error, the error becomes the new result and will be\n * passed to the next errback in the execution chain.\n *\n * If the function returns a Deferred, the execution sequence will be blocked\n * until that Deferred fires. Its result will be passed to the next callback (or\n * errback if it is an error result) in this Deferred's execution sequence.\n *\n * @param {function(this:T,VALUE):?} cb The function to be called with a\n *     successful result.\n * @param {T=} opt_scope An optional scope to call the callback in.\n * @return {!goog.async.Deferred} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addCallback = function(cb, opt_scope) {\n  return this.addCallbacks(cb, null, opt_scope);\n};\n\n\n/**\n * Register a callback function to be called with an error result. If no value\n * is returned by the function, the error result is unchanged. If a new error\n * value is returned or thrown, that error becomes the Deferred result and will\n * be passed to the next errback in the execution sequence.\n *\n * If the errback function handles the error by returning a non-error value,\n * that result will be passed to the next normal callback in the sequence.\n *\n * If the function returns a Deferred, the execution sequence will be blocked\n * until that Deferred fires. Its result will be passed to the next callback (or\n * errback if it is an error result) in this Deferred's execution sequence.\n *\n * @param {function(this:T,?):?} eb The function to be called on an\n *     unsuccessful result.\n * @param {T=} opt_scope An optional scope to call the errback in.\n * @return {!goog.async.Deferred<VALUE>} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addErrback = function(eb, opt_scope) {\n  return this.addCallbacks(null, eb, opt_scope);\n};\n\n\n/**\n * Registers one function as both a callback and errback.\n *\n * @param {function(this:T,?):?} f The function to be called on any result.\n * @param {T=} opt_scope An optional scope to call the function in.\n * @return {!goog.async.Deferred} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addBoth = function(f, opt_scope) {\n  return this.addCallbacks(f, f, opt_scope);\n};\n\n\n/**\n * Like addBoth, but propagates uncaught exceptions in the errback.\n *\n * @param {function(this:T,?):?} f The function to be called on any result.\n * @param {T=} opt_scope An optional scope to call the function in.\n * @return {!goog.async.Deferred<VALUE>} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addFinally = function(f, opt_scope) {\n  return this.addCallbacks(f, function(err) {\n    var result = f.call(/** @type {?} */ (this), err);\n    if (!goog.isDef(result)) {\n      throw err;\n    }\n    return result;\n  }, opt_scope);\n};\n\n\n/**\n * Registers a callback function and an errback function at the same position\n * in the execution sequence. Only one of these functions will execute,\n * depending on the error state during the execution sequence.\n *\n * NOTE: This is not equivalent to {@code def.addCallback().addErrback()}! If\n * the callback is invoked, the errback will be skipped, and vice versa.\n *\n * @param {?(function(this:T,VALUE):?)} cb The function to be called on a\n *     successful result.\n * @param {?(function(this:T,?):?)} eb The function to be called on an\n *     unsuccessful result.\n * @param {T=} opt_scope An optional scope to call the functions in.\n * @return {!goog.async.Deferred} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addCallbacks = function(cb, eb, opt_scope) {\n  goog.asserts.assert(!this.blocking_, 'Blocking Deferreds can not be re-used');\n  this.sequence_.push([cb, eb, opt_scope]);\n  if (this.hasFired()) {\n    this.fire_();\n  }\n  return this;\n};\n\n\n/**\n * Implements {@see goog.Thenable} for seamless integration with\n * {@see goog.Promise}.\n * Deferred results are mutable and may represent multiple values over\n * their lifetime. Calling `then` on a Deferred returns a Promise\n * with the result of the Deferred at that point in its callback chain.\n * Note that if the Deferred result is never mutated, and only\n * `then` calls are made, the Deferred will behave like a Promise.\n *\n * @override\n */\ngoog.async.Deferred.prototype.then = function(opt_onFulfilled, opt_onRejected,\n    opt_context) {\n  var resolve, reject;\n  var promise = new goog.Promise(function(res, rej) {\n    // Copying resolvers to outer scope, so that they are available when the\n    // deferred callback fires (which may be synchronous).\n    resolve = res;\n    reject = rej;\n  });\n  this.addCallbacks(resolve, function(reason) {\n    if (reason instanceof goog.async.Deferred.CanceledError) {\n      promise.cancel();\n    } else {\n      reject(reason);\n    }\n  });\n  return promise.then(opt_onFulfilled, opt_onRejected, opt_context);\n};\ngoog.Thenable.addImplementation(goog.async.Deferred);\n\n\n/**\n * Links another Deferred to the end of this Deferred's execution sequence. The\n * result of this execution sequence will be passed as the starting result for\n * the chained Deferred, invoking either its first callback or errback.\n *\n * @param {!goog.async.Deferred} otherDeferred The Deferred to chain.\n * @return {!goog.async.Deferred} This Deferred.\n */\ngoog.async.Deferred.prototype.chainDeferred = function(otherDeferred) {\n  this.addCallbacks(\n      otherDeferred.callback, otherDeferred.errback, otherDeferred);\n  return this;\n};\n\n\n/**\n * Makes this Deferred wait for another Deferred's execution sequence to\n * complete before continuing.\n *\n * This is equivalent to adding a callback that returns `otherDeferred`,\n * but doesn't prevent additional callbacks from being added to\n * `otherDeferred`.\n *\n * @param {!goog.async.Deferred|!goog.Thenable} otherDeferred The Deferred\n *     to wait for.\n * @return {!goog.async.Deferred} This Deferred.\n */\ngoog.async.Deferred.prototype.awaitDeferred = function(otherDeferred) {\n  if (!(otherDeferred instanceof goog.async.Deferred)) {\n    // The Thenable case.\n    return this.addCallback(function() {\n      return otherDeferred;\n    });\n  }\n  return this.addCallback(goog.bind(otherDeferred.branch, otherDeferred));\n};\n\n\n/**\n * Creates a branch off this Deferred's execution sequence, and returns it as a\n * new Deferred. The branched Deferred's starting result will be shared with the\n * parent at the point of the branch, even if further callbacks are added to the\n * parent.\n *\n * All branches at the same stage in the execution sequence will receive the\n * same starting value.\n *\n * @param {boolean=} opt_propagateCancel If cancel() is called on every child\n *     branch created with opt_propagateCancel, the parent will be canceled as\n *     well.\n * @return {!goog.async.Deferred<VALUE>} A Deferred that will be started with\n *     the computed result from this stage in the execution sequence.\n */\ngoog.async.Deferred.prototype.branch = function(opt_propagateCancel) {\n  var d = new goog.async.Deferred();\n  this.chainDeferred(d);\n  if (opt_propagateCancel) {\n    d.parent_ = this;\n    this.branches_++;\n  }\n  return d;\n};\n\n\n/**\n * @return {boolean} Whether the execution sequence has been started on this\n *     Deferred by invoking `callback` or `errback`.\n */\ngoog.async.Deferred.prototype.hasFired = function() {\n  return this.fired_;\n};\n\n\n/**\n * @param {*} res The latest result in the execution sequence.\n * @return {boolean} Whether the current result is an error that should cause\n *     the next errback to fire. May be overridden by subclasses to handle\n *     special error types.\n * @protected\n */\ngoog.async.Deferred.prototype.isError = function(res) {\n  return res instanceof Error;\n};\n\n\n/**\n * @return {boolean} Whether an errback exists in the remaining sequence.\n * @private\n */\ngoog.async.Deferred.prototype.hasErrback_ = function() {\n  return goog.array.some(this.sequence_, function(sequenceRow) {\n    // The errback is the second element in the array.\n    return goog.isFunction(sequenceRow[1]);\n  });\n};\n\n\n/**\n * Exhausts the execution sequence while a result is available. The result may\n * be modified by callbacks or errbacks, and execution will block if the\n * returned result is an incomplete Deferred.\n *\n * @private\n */\ngoog.async.Deferred.prototype.fire_ = function() {\n  if (this.unhandledErrorId_ && this.hasFired() && this.hasErrback_()) {\n    // It is possible to add errbacks after the Deferred has fired. If a new\n    // errback is added immediately after the Deferred encountered an unhandled\n    // error, but before that error is rethrown, the error is unscheduled.\n    goog.async.Deferred.unscheduleError_(this.unhandledErrorId_);\n    this.unhandledErrorId_ = 0;\n  }\n\n  if (this.parent_) {\n    this.parent_.branches_--;\n    delete this.parent_;\n  }\n\n  var res = this.result_;\n  var unhandledException = false;\n  var isNewlyBlocked = false;\n\n  while (this.sequence_.length && !this.blocked_) {\n    var sequenceEntry = this.sequence_.shift();\n\n    var callback = sequenceEntry[0];\n    var errback = sequenceEntry[1];\n    var scope = sequenceEntry[2];\n\n    var f = this.hadError_ ? errback : callback;\n    if (f) {\n\n      try {\n        var ret = f.call(scope || this.defaultScope_, res);\n\n        // If no result, then use previous result.\n        if (goog.isDef(ret)) {\n          // Bubble up the error as long as the return value hasn't changed.\n          this.hadError_ = this.hadError_ && (ret == res || this.isError(ret));\n          this.result_ = res = ret;\n        }\n\n        if (goog.Thenable.isImplementedBy(res) ||\n            (typeof goog.global['Promise'] === 'function' &&\n            res instanceof goog.global['Promise'])) {\n          isNewlyBlocked = true;\n          this.blocked_ = true;\n        }\n\n      } catch (ex) {\n        res = ex;\n        this.hadError_ = true;\n        this.makeStackTraceLong_(res);\n\n        if (!this.hasErrback_()) {\n          // If an error is thrown with no additional errbacks in the queue,\n          // prepare to rethrow the error.\n          unhandledException = true;\n        }\n      }\n    }\n  }\n\n  this.result_ = res;\n\n  if (isNewlyBlocked) {\n    var onCallback = goog.bind(this.continue_, this, true /* isSuccess */);\n    var onErrback = goog.bind(this.continue_, this, false /* isSuccess */);\n\n    if (res instanceof goog.async.Deferred) {\n      res.addCallbacks(onCallback, onErrback);\n      res.blocking_ = true;\n    } else {\n      /** @type {!IThenable} */ (res).then(onCallback, onErrback);\n    }\n  } else if (goog.async.Deferred.STRICT_ERRORS && this.isError(res) &&\n      !(res instanceof goog.async.Deferred.CanceledError)) {\n    this.hadError_ = true;\n    unhandledException = true;\n  }\n\n  if (unhandledException) {\n    // Rethrow the unhandled error after a timeout. Execution will continue, but\n    // the error will be seen by global handlers and the user. The throw will\n    // be canceled if another errback is appended before the timeout executes.\n    // The error's original stack trace is preserved where available.\n    this.unhandledErrorId_ = goog.async.Deferred.scheduleError_(res);\n  }\n};\n\n\n/**\n * Creates a Deferred that has an initial result.\n *\n * @param {*=} opt_result The result.\n * @return {!goog.async.Deferred} The new Deferred.\n */\ngoog.async.Deferred.succeed = function(opt_result) {\n  var d = new goog.async.Deferred();\n  d.callback(opt_result);\n  return d;\n};\n\n\n/**\n * Creates a Deferred that fires when the given promise resolves.\n * Use only during migration to Promises.\n *\n * Note: If the promise resolves to a thenable value (which is not allowed by\n * conforming promise implementations), then the deferred may behave\n * unexpectedly as it tries to wait on it. This should not be a risk when using\n * goog.Promise, goog.async.Deferred, or native Promise objects.\n *\n * @param {!IThenable<T>} promise\n * @return {!goog.async.Deferred<T>} The new Deferred.\n * @template T\n */\ngoog.async.Deferred.fromPromise = function(promise) {\n  var d = new goog.async.Deferred();\n  promise.then(\n      function(value) {\n        d.callback(value);\n      },\n      function(error) {\n        d.errback(error);\n      });\n  return d;\n};\n\n\n/**\n * Creates a Deferred that has an initial error result.\n *\n * @param {*} res The error result.\n * @return {!goog.async.Deferred} The new Deferred.\n */\ngoog.async.Deferred.fail = function(res) {\n  var d = new goog.async.Deferred();\n  d.errback(res);\n  return d;\n};\n\n\n/**\n * Creates a Deferred that has already been canceled.\n *\n * @return {!goog.async.Deferred} The new Deferred.\n */\ngoog.async.Deferred.canceled = function() {\n  var d = new goog.async.Deferred();\n  d.cancel();\n  return d;\n};\n\n\n/**\n * Normalizes values that may or may not be Deferreds.\n *\n * If the input value is a Deferred, the Deferred is branched (so the original\n * execution sequence is not modified) and the input callback added to the new\n * branch. The branch is returned to the caller.\n *\n * If the input value is not a Deferred, the callback will be executed\n * immediately and an already firing Deferred will be returned to the caller.\n *\n * In the following (contrived) example, if <code>isImmediate</code> is true\n * then 3 is alerted immediately, otherwise 6 is alerted after a 2-second delay.\n *\n * <pre>\n * var value;\n * if (isImmediate) {\n *   value = 3;\n * } else {\n *   value = new goog.async.Deferred();\n *   setTimeout(function() { value.callback(6); }, 2000);\n * }\n *\n * var d = goog.async.Deferred.when(value, alert);\n * </pre>\n *\n * @param {*} value Deferred or normal value to pass to the callback.\n * @param {function(this:T, ?):?} callback The callback to execute.\n * @param {T=} opt_scope An optional scope to call the callback in.\n * @return {!goog.async.Deferred} A new Deferred that will call the input\n *     callback with the input value.\n * @template T\n */\ngoog.async.Deferred.when = function(value, callback, opt_scope) {\n  if (value instanceof goog.async.Deferred) {\n    return value.branch(true).addCallback(callback, opt_scope);\n  } else {\n    return goog.async.Deferred.succeed(value).addCallback(callback, opt_scope);\n  }\n};\n\n\n\n/**\n * An error sub class that is used when a Deferred has already been called.\n * @param {!goog.async.Deferred} deferred The Deferred.\n *\n * @constructor\n * @extends {goog.debug.Error}\n */\ngoog.async.Deferred.AlreadyCalledError = function(deferred) {\n  goog.debug.Error.call(this);\n\n  /**\n   * The Deferred that raised this error.\n   * @type {goog.async.Deferred}\n   */\n  this.deferred = deferred;\n};\ngoog.inherits(goog.async.Deferred.AlreadyCalledError, goog.debug.Error);\n\n\n/** @override */\ngoog.async.Deferred.AlreadyCalledError.prototype.message =\n    'Deferred has already fired';\n\n\n/** @override */\ngoog.async.Deferred.AlreadyCalledError.prototype.name = 'AlreadyCalledError';\n\n\n\n/**\n * An error sub class that is used when a Deferred is canceled.\n *\n * @param {!goog.async.Deferred} deferred The Deferred object.\n * @constructor\n * @extends {goog.debug.Error}\n */\ngoog.async.Deferred.CanceledError = function(deferred) {\n  goog.debug.Error.call(this);\n\n  /**\n   * The Deferred that raised this error.\n   * @type {goog.async.Deferred}\n   */\n  this.deferred = deferred;\n};\ngoog.inherits(goog.async.Deferred.CanceledError, goog.debug.Error);\n\n\n/** @override */\ngoog.async.Deferred.CanceledError.prototype.message = 'Deferred was canceled';\n\n\n/** @override */\ngoog.async.Deferred.CanceledError.prototype.name = 'CanceledError';\n\n\n\n/**\n * Wrapper around errors that are scheduled to be thrown by failing deferreds\n * after a timeout.\n *\n * @param {*} error Error from a failing deferred.\n * @constructor\n * @final\n * @private\n * @struct\n */\ngoog.async.Deferred.Error_ = function(error) {\n  /** @const @private {number} */\n  this.id_ = goog.global.setTimeout(goog.bind(this.throwError, this), 0);\n\n  /** @const @private {*} */\n  this.error_ = error;\n};\n\n\n/**\n * Actually throws the error and removes it from the list of pending\n * deferred errors.\n */\ngoog.async.Deferred.Error_.prototype.throwError = function() {\n  goog.asserts.assert(goog.async.Deferred.errorMap_[this.id_],\n      'Cannot throw an error that is not scheduled.');\n  delete goog.async.Deferred.errorMap_[this.id_];\n  throw this.error_;\n};\n\n\n/**\n * Resets the error throw timer.\n */\ngoog.async.Deferred.Error_.prototype.resetTimer = function() {\n  goog.global.clearTimeout(this.id_);\n};\n\n\n/**\n * Map of unhandled errors scheduled to be rethrown in a future timestep.\n * @private {!Object<(number|string), goog.async.Deferred.Error_>}\n */\ngoog.async.Deferred.errorMap_ = {};\n\n\n/**\n * Schedules an error to be thrown after a delay.\n * @param {*} error Error from a failing deferred.\n * @return {number} Id of the error.\n * @private\n */\ngoog.async.Deferred.scheduleError_ = function(error) {\n  var deferredError = new goog.async.Deferred.Error_(error);\n  goog.async.Deferred.errorMap_[deferredError.id_] = deferredError;\n  return deferredError.id_;\n};\n\n\n/**\n * Unschedules an error from being thrown.\n * @param {number} id Id of the deferred error to unschedule.\n * @private\n */\ngoog.async.Deferred.unscheduleError_ = function(id) {\n  var error = goog.async.Deferred.errorMap_[id];\n  if (error) {\n    error.resetTimer();\n    delete goog.async.Deferred.errorMap_[id];\n  }\n};\n\n\n/**\n * Asserts that there are no pending deferred errors. If there are any\n * scheduled errors, one will be thrown immediately to make this function fail.\n */\ngoog.async.Deferred.assertNoErrors = function() {\n  var map = goog.async.Deferred.errorMap_;\n  for (var key in map) {\n    var error = map[key];\n    error.resetTimer();\n    error.throwError();\n  }\n};\n","~:compiled-at",1554900569622,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.mochikit.async.deferred.js\",\n\"lineCount\":456,\n\"mappings\":\"AAuBAA,IAAAC,QAAA,CAAa,qBAAb,CAAA;AACAD,IAAAC,QAAA,CAAa,wCAAb,CAAA;AACAD,IAAAC,QAAA,CAAa,mCAAb,CAAA;AAEAD,IAAAE,QAAA,CAAa,cAAb,CAAA;AACAF,IAAAE,QAAA,CAAa,eAAb,CAAA;AACAF,IAAAE,QAAA,CAAa,YAAb,CAAA;AACAF,IAAAE,QAAA,CAAa,cAAb,CAAA;AACAF,IAAAE,QAAA,CAAa,kBAAb,CAAA;AA8CA;;;;;;;AAAAF,IAAAG,MAAAC,SAAA,GAAsBC,QAAQ,CAACC,oBAAD,EAAuBC,gBAAvB,CAAyC;AAOrE,yCAAA,IAAAC,UAAA,GAAiB,EAAjB;AAOA,+CAAA,IAAAC,kBAAA,GAAyBH,oBAAzB;AAOA,iCAAA,IAAAI,cAAA,GAAqBH,gBAArB,IAAyC,IAAzC;AAOA,kCAAA,IAAAI,OAAA,GAAc,KAAd;AAOA,kCAAA,IAAAC,UAAA,GAAiB,KAAjB;AAQA,4BAAA,IAAAC,QAAA,GAAeC,SAAf;AASA,kCAAA,IAAAC,SAAA,GAAgB,KAAhB;AAWA,kCAAA,IAAAC,UAAA,GAAiB,KAAjB;AAQA,kCAAA,IAAAC,kBAAA,GAAyB,KAAzB;AAUA,iCAAA,IAAAC,kBAAA,GAAyB,CAAzB;AAQA,+CAAA,IAAAC,QAAA,GAAe,IAAf;AAQA,iCAAA,IAAAC,UAAA,GAAiB,CAAjB;AAEA,MAAIpB,IAAAG,MAAAC,SAAAiB,kBAAJ,CAA2C;AAMzC,oCAAA,IAAAC,kBAAA,GAAyB,IAAzB;AACA,QAAIC,KAAAC,kBAAJ,CAA6B;AAC3B,UAAIC,SAAS,CAAEC,MAAO,EAAT,CAAb;AACAH,WAAAC,kBAAA,CAAwBC,MAAxB,EAAgCzB,IAAAG,MAAAC,SAAhC,CAAA;AAEA,UAAI,MAAOqB,OAAAC,MAAX,IAA2B,QAA3B;AAGE,YAAAJ,kBAAA,GAAyBG,MAAAC,MAAAC,QAAA,CAAqB,WAArB,EAAkC,EAAlC,CAAzB;AAHF;AAJ2B;AAPY;AAnG0B,CAAvE;AA4HA,yBAAA3B,IAAA4B,OAAA,CAAY,mCAAZ,EAAiD,KAAjD,CAAA;AAOA,yBAAA5B,IAAA4B,OAAA,CAAY,uCAAZ,EAAqD,KAArD,CAAA;AAmBA;;;AAAA5B,IAAAG,MAAAC,SAAAyB,UAAAC,OAAA,GAAuCC,QAAQ,CAACC,cAAD,CAAiB;AAC9D,MAAI,CAAC,IAAAC,SAAA,EAAL,CAAsB;AACpB,QAAI,IAAAd,QAAJ,CAAkB;AAIhB,UAAIe,SAAS,IAAAf,QAAb;AACA,aAAO,IAAAA,QAAP;AACA,UAAIa,cAAJ;AACEE,cAAAJ,OAAA,CAAcE,cAAd,CAAA;AADF;AAGEE,cAAAC,cAAA,EAAA;AAHF;AANgB;AAalB,QAAI,IAAA1B,kBAAJ;AAEE,UAAAA,kBAAA2B,KAAA,CAA4B,IAAA1B,cAA5B,EAAgD,IAAhD,CAAA;AAFF;AAIE,UAAAO,kBAAA,GAAyB,IAAzB;AAJF;AAMA,QAAI,CAAC,IAAAgB,SAAA,EAAL;AACE,UAAAI,QAAA,CAAa,IAAIrC,IAAAG,MAAAC,SAAAkC,cAAJ,CAAsC,IAAtC,CAAb,CAAA;AADF;AApBoB,GAAtB;AAuBO,QAAI,IAAAzB,QAAJ,YAA4Bb,IAAAG,MAAAC,SAA5B;AACL,UAAAS,QAAAiB,OAAA,EAAA;AADK;AAvBP;AAD8D,CAAhE;AAoCA,gBAAA9B,IAAAG,MAAAC,SAAAyB,UAAAM,cAAA,GAA8CI,QAAQ,EAAG;AACvD,MAAAnB,UAAA,EAAA;AACA,MAAI,IAAAA,UAAJ,IAAsB,CAAtB;AACE,QAAAU,OAAA,EAAA;AADF;AAFuD,CAAzD;AAgBA;;;;;AAAA9B,IAAAG,MAAAC,SAAAyB,UAAAW,UAAA,GAA0CC,QAAQ,CAACC,SAAD,EAAYC,GAAZ,CAAiB;AACjE,MAAA5B,SAAA,GAAgB,KAAhB;AACA,MAAA6B,cAAA,CAAmBF,SAAnB,EAA8BC,GAA9B,CAAA;AAFiE,CAAnE;AAcA;;;;;AAAA3C,IAAAG,MAAAC,SAAAyB,UAAAe,cAAA,GAA8CC,QAAQ,CAACH,SAAD,EAAYC,GAAZ,CAAiB;AACrE,MAAAhC,OAAA,GAAc,IAAd;AACA,MAAAE,QAAA,GAAe8B,GAAf;AACA,MAAA/B,UAAA,GAAiB,CAAC8B,SAAlB;AACA,MAAAI,MAAA,EAAA;AAJqE,CAAvE;AAcA,gCAAA9C,IAAAG,MAAAC,SAAAyB,UAAAkB,OAAA,GAAuCC,QAAQ,EAAG;AAChD,MAAI,IAAAf,SAAA,EAAJ,CAAqB;AACnB,QAAI,CAAC,IAAAhB,kBAAL;AACE,YAAM,IAAIjB,IAAAG,MAAAC,SAAA6C,mBAAJ,CAA2C,IAA3C,CAAN;AADF;AAGA,QAAAhC,kBAAA,GAAyB,KAAzB;AAJmB;AAD2B,CAAlD;AAeA;;;AAAAjB,IAAAG,MAAAC,SAAAyB,UAAAqB,SAAA,GAAyCC,QAAQ,CAACC,UAAD,CAAa;AAC5D,MAAAL,OAAA,EAAA;AACA,MAAAM,mBAAA,CAAwBD,UAAxB,CAAA;AACA,MAAAR,cAAA,CAAmB,IAAnB,EAAyCQ,UAAzC,CAAA;AAH4D,CAA9D;AAYA;;;AAAApD,IAAAG,MAAAC,SAAAyB,UAAAQ,QAAA,GAAwCiB,QAAQ,CAACF,UAAD,CAAa;AAC3D,MAAAL,OAAA,EAAA;AACA,MAAAM,mBAAA,CAAwBD,UAAxB,CAAA;AACA,MAAAG,oBAAA,CAAyBH,UAAzB,CAAA;AACA,MAAAR,cAAA,CAAmB,KAAnB,EAA0CQ,UAA1C,CAAA;AAJ2D,CAA7D;AAeA;;;;AAAApD,IAAAG,MAAAC,SAAAyB,UAAA0B,oBAAA,GAAoDC,QAAQ,CAACC,KAAD,CAAQ;AAClE,MAAI,CAACzD,IAAAG,MAAAC,SAAAiB,kBAAL;AACE;AADF;AAGA,MAAI,IAAAC,kBAAJ,IAA8BtB,IAAA0D,SAAA,CAAcD,KAAd,CAA9B,IAAsDA,KAAA/B,MAAtD,IAGK,uBAADiC,KAAA,CAA+BF,KAAA/B,MAA/B,CAHJ;AAIE+B,SAAA/B,MAAA,GAAc+B,KAAA/B,MAAd,GAA4B,yBAA5B,GACI,IAAAJ,kBADJ;AAJF;AAJkE,CAApE;AAoBA;;;;;AAAAtB,IAAAG,MAAAC,SAAAyB,UAAAwB,mBAAA,GAAmDO,QAAQ,CAACC,GAAD,CAAM;AAC/D7D,MAAA8D,QAAAC,OAAA,CACI,EAAEF,GAAF,YAAiB7D,IAAAG,MAAAC,SAAjB,CADJ,EAEI,sEAFJ,CAAA;AAD+D,CAAjE;AA0BA;;;;;;AAAAJ,IAAAG,MAAAC,SAAAyB,UAAAmC,YAAA,GAA4CC,QAAQ,CAACC,EAAD,EAAKC,SAAL,CAAgB;AAClE,SAAO,IAAAC,aAAA,CAAkBF,EAAlB,EAAsB,IAAtB,EAA4BC,SAA5B,CAAP;AADkE,CAApE;AAwBA;;;;;;AAAAnE,IAAAG,MAAAC,SAAAyB,UAAAwC,WAAA,GAA2CC,QAAQ,CAACC,EAAD,EAAKJ,SAAL,CAAgB;AACjE,SAAO,IAAAC,aAAA,CAAkB,IAAlB,EAAwBG,EAAxB,EAA4BJ,SAA5B,CAAP;AADiE,CAAnE;AAaA;;;;;;AAAAnE,IAAAG,MAAAC,SAAAyB,UAAA2C,QAAA,GAAwCC,QAAQ,CAACC,CAAD,EAAIP,SAAJ,CAAe;AAC7D,SAAO,IAAAC,aAAA,CAAkBM,CAAlB,EAAqBA,CAArB,EAAwBP,SAAxB,CAAP;AAD6D,CAA/D;AAaA;;;;;;AAAAnE,IAAAG,MAAAC,SAAAyB,UAAA8C,WAAA,GAA2CC,QAAQ,CAACF,CAAD,EAAIP,SAAJ,CAAe;AAChE,SAAO,IAAAC,aAAA,CAAkBM,CAAlB,EAAqB,QAAQ,CAACG,GAAD,CAAM;AACxC,QAAIC,SAASJ,CAAAtC,KAAA,kBAAwB,CAAC,IAAD,CAAxB,EAAgCyC,GAAhC,CAAb;AACA,QAAI,CAAC7E,IAAA+E,MAAA,CAAWD,MAAX,CAAL;AACE,YAAMD,GAAN;AADF;AAGA,WAAOC,MAAP;AALwC,GAAnC,EAMJX,SANI,CAAP;AADgE,CAAlE;AA2BA;;;;;;;AAAAnE,IAAAG,MAAAC,SAAAyB,UAAAuC,aAAA,GAA6CY,QAAQ,CAACd,EAAD,EAAKK,EAAL,EAASJ,SAAT,CAAoB;AACvEnE,MAAA8D,QAAAC,OAAA,CAAoB,CAAC,IAAA/C,UAArB,EAAqC,uCAArC,CAAA;AACA,MAAAR,UAAAyE,KAAA,CAAoB,CAACf,EAAD,EAAKK,EAAL,EAASJ,SAAT,CAApB,CAAA;AACA,MAAI,IAAAlC,SAAA,EAAJ;AACE,QAAAa,MAAA,EAAA;AADF;AAGA,SAAO,IAAP;AANuE,CAAzE;AAqBA,iBAAA9C,IAAAG,MAAAC,SAAAyB,UAAAqD,KAAA,GAAqCC,QAAQ,CAACC,eAAD,EAAkBC,cAAlB,EACzCC,WADyC,CAC5B;AACf,MAAIC,OAAJ,EAAaC,MAAb;AACA,MAAIC,UAAU,IAAIzF,IAAA0F,QAAJ,CAAiB,QAAQ,CAAC/C,GAAD,EAAMgD,GAAN,CAAW;AAGhDJ,WAAA,GAAU5C,GAAV;AACA6C,UAAA,GAASG,GAAT;AAJgD,GAApC,CAAd;AAMA,MAAAvB,aAAA,CAAkBmB,OAAlB,EAA2B,QAAQ,CAACK,MAAD,CAAS;AAC1C,QAAIA,MAAJ,YAAsB5F,IAAAG,MAAAC,SAAAkC,cAAtB;AACEmD,aAAA3D,OAAA,EAAA;AADF;AAGE0D,YAAA,CAAOI,MAAP,CAAA;AAHF;AAD0C,GAA5C,CAAA;AAOA,SAAOH,OAAAP,KAAA,CAAaE,eAAb,EAA8BC,cAA9B,EAA8CC,WAA9C,CAAP;AAfe,CADjB;AAkBAtF,IAAA6F,SAAAC,kBAAA,CAAgC9F,IAAAG,MAAAC,SAAhC,CAAA;AAWA;;;;AAAAJ,IAAAG,MAAAC,SAAAyB,UAAAkE,cAAA,GAA8CC,QAAQ,CAACC,aAAD,CAAgB;AACpE,MAAA7B,aAAA,CACI6B,aAAA/C,SADJ,EAC4B+C,aAAA5D,QAD5B,EACmD4D,aADnD,CAAA;AAEA,SAAO,IAAP;AAHoE,CAAtE;AAmBA;;;;AAAAjG,IAAAG,MAAAC,SAAAyB,UAAAqE,cAAA,GAA8CC,QAAQ,CAACF,aAAD,CAAgB;AACpE,MAAI,EAAEA,aAAF,YAA2BjG,IAAAG,MAAAC,SAA3B,CAAJ;AAEE,WAAO,IAAA4D,YAAA,CAAiB,QAAQ,EAAG;AACjC,aAAOiC,aAAP;AADiC,KAA5B,CAAP;AAFF;AAMA,SAAO,IAAAjC,YAAA,CAAiBhE,IAAAoG,KAAA,CAAUH,aAAAI,OAAV,EAAgCJ,aAAhC,CAAjB,CAAP;AAPoE,CAAtE;AA0BA;;;;AAAAjG,IAAAG,MAAAC,SAAAyB,UAAAwE,OAAA,GAAuCC,QAAQ,CAACC,mBAAD,CAAsB;AACnE,MAAIC,IAAI,IAAIxG,IAAAG,MAAAC,SAAZ;AACA,MAAA2F,cAAA,CAAmBS,CAAnB,CAAA;AACA,MAAID,mBAAJ,CAAyB;AACvBC,KAAArF,QAAA,GAAY,IAAZ;AACA,QAAAC,UAAA,EAAA;AAFuB;AAIzB,SAAOoF,CAAP;AAPmE,CAArE;AAeA;;;AAAAxG,IAAAG,MAAAC,SAAAyB,UAAAI,SAAA,GAAyCwE,QAAQ,EAAG;AAClD,SAAO,IAAA9F,OAAP;AADkD,CAApD;AAYA;;;;;AAAAX,IAAAG,MAAAC,SAAAyB,UAAA6E,QAAA,GAAwCC,QAAQ,CAAChE,GAAD,CAAM;AACpD,SAAOA,GAAP,YAAsBpB,KAAtB;AADoD,CAAtD;AASA;;;;AAAAvB,IAAAG,MAAAC,SAAAyB,UAAA+E,YAAA,GAA4CC,QAAQ,EAAG;AACrD,SAAO7G,IAAA8G,MAAAC,KAAA,CAAgB,IAAAvG,UAAhB,EAAgC,QAAQ,CAACwG,WAAD,CAAc;AAE3D,WAAOhH,IAAAiH,WAAA,CAAgBD,WAAA,CAAY,CAAZ,CAAhB,CAAP;AAF2D,GAAtD,CAAP;AADqD,CAAvD;AAeA,gBAAAhH,IAAAG,MAAAC,SAAAyB,UAAAiB,MAAA,GAAsCoE,QAAQ,EAAG;AAC/C,MAAI,IAAAhG,kBAAJ,IAA8B,IAAAe,SAAA,EAA9B,IAAiD,IAAA2E,YAAA,EAAjD,CAAqE;AAInE5G,QAAAG,MAAAC,SAAA+G,iBAAA,CAAqC,IAAAjG,kBAArC,CAAA;AACA,QAAAA,kBAAA,GAAyB,CAAzB;AALmE;AAQrE,MAAI,IAAAC,QAAJ,CAAkB;AAChB,QAAAA,QAAAC,UAAA,EAAA;AACA,WAAO,IAAAD,QAAP;AAFgB;AAKlB,MAAIwB,MAAM,IAAA9B,QAAV;AACA,MAAIuG,qBAAqB,KAAzB;AACA,MAAIC,iBAAiB,KAArB;AAEA,SAAO,IAAA7G,UAAA8G,OAAP,IAAgC,CAAC,IAAAvG,SAAjC,CAAgD;AAC9C,QAAIwG,gBAAgB,IAAA/G,UAAAgH,MAAA,EAApB;AAEA,QAAItE,WAAWqE,aAAA,CAAc,CAAd,CAAf;AACA,QAAIlF,UAAUkF,aAAA,CAAc,CAAd,CAAd;AACA,QAAIE,QAAQF,aAAA,CAAc,CAAd,CAAZ;AAEA,QAAI7C,IAAI,IAAA9D,UAAA,GAAiByB,OAAjB,GAA2Ba,QAAnC;AACA,QAAIwB,CAAJ;AAEE,SAAI;AACF,YAAIgD,MAAMhD,CAAAtC,KAAA,CAAOqF,KAAP,IAAgB,IAAA/G,cAAhB,EAAoCiC,GAApC,CAAV;AAGA,YAAI3C,IAAA+E,MAAA,CAAW2C,GAAX,CAAJ,CAAqB;AAEnB,cAAA9G,UAAA,GAAiB,IAAAA,UAAjB,KAAoC8G,GAApC,IAA2C/E,GAA3C,IAAkD,IAAA+D,QAAA,CAAagB,GAAb,CAAlD;AACA,cAAA7G,QAAA,GAAe8B,GAAf,GAAqB+E,GAArB;AAHmB;AAMrB,YAAI1H,IAAA6F,SAAA8B,gBAAA,CAA8BhF,GAA9B,CAAJ,IACK,MAAO3C,KAAA4H,OAAA,CAAY,SAAZ,CADZ,KACuC,UADvC,IAEIjF,GAFJ,YAEmB3C,IAAA4H,OAAA,CAAY,SAAZ,CAFnB,CAE4C;AAC1CP,wBAAA,GAAiB,IAAjB;AACA,cAAAtG,SAAA,GAAgB,IAAhB;AAF0C;AAZ1C,OAiBF,QAAO8G,EAAP,CAAW;AACXlF,WAAA,GAAMkF,EAAN;AACA,YAAAjH,UAAA,GAAiB,IAAjB;AACA,YAAA2C,oBAAA,CAAyBZ,GAAzB,CAAA;AAEA,YAAI,CAAC,IAAAiE,YAAA,EAAL;AAGEQ,4BAAA,GAAqB,IAArB;AAHF;AALW;AAnBf;AAR8C;AAyChD,MAAAvG,QAAA,GAAe8B,GAAf;AAEA,MAAI0E,cAAJ,CAAoB;AAClB,QAAIS,aAAa9H,IAAAoG,KAAA,CAAU,IAAA5D,UAAV,EAA0B,IAA1B,EAAgC,IAAhC,CAAjB;AACA,QAAIuF,YAAY/H,IAAAoG,KAAA,CAAU,IAAA5D,UAAV,EAA0B,IAA1B,EAAgC,KAAhC,CAAhB;AAEA,QAAIG,GAAJ,YAAmB3C,IAAAG,MAAAC,SAAnB,CAAwC;AACtCuC,SAAAyB,aAAA,CAAiB0D,UAAjB,EAA6BC,SAA7B,CAAA;AACApF,SAAA3B,UAAA,GAAgB,IAAhB;AAFsC,KAAxC;AAI4BkE,gCAAA,CAACvC,GAAD,CAAAuC,KAAA,CAAW4C,UAAX,EAAuBC,SAAvB,CAAA;AAJ5B;AAJkB,GAApB;AAUO,QAAI/H,IAAAG,MAAAC,SAAA4H,cAAJ,IAAyC,IAAAtB,QAAA,CAAa/D,GAAb,CAAzC,IACH,EAAEA,GAAF,YAAiB3C,IAAAG,MAAAC,SAAAkC,cAAjB,CADG,CACkD;AACvD,UAAA1B,UAAA,GAAiB,IAAjB;AACAwG,wBAAA,GAAqB,IAArB;AAFuD;AAXzD;AAgBA,MAAIA,kBAAJ;AAKE,QAAAlG,kBAAA,GAAyBlB,IAAAG,MAAAC,SAAA6H,eAAA,CAAmCtF,GAAnC,CAAzB;AALF;AA7E+C,CAAjD;AA6FA;;;;AAAA3C,IAAAG,MAAAC,SAAA8H,QAAA,GAA8BC,QAAQ,CAAC/E,UAAD,CAAa;AACjD,MAAIoD,IAAI,IAAIxG,IAAAG,MAAAC,SAAZ;AACAoG,GAAAtD,SAAA,CAAWE,UAAX,CAAA;AACA,SAAOoD,CAAP;AAHiD,CAAnD;AAoBA;;;;;AAAAxG,IAAAG,MAAAC,SAAAgI,YAAA,GAAkCC,QAAQ,CAAC5C,OAAD,CAAU;AAClD,MAAIe,IAAI,IAAIxG,IAAAG,MAAAC,SAAZ;AACAqF,SAAAP,KAAA,CACI,QAAQ,CAACoD,KAAD,CAAQ;AACd9B,KAAAtD,SAAA,CAAWoF,KAAX,CAAA;AADc,GADpB,EAII,QAAQ,CAAC7E,KAAD,CAAQ;AACd+C,KAAAnE,QAAA,CAAUoB,KAAV,CAAA;AADc,GAJpB,CAAA;AAOA,SAAO+C,CAAP;AATkD,CAApD;AAmBA;;;;AAAAxG,IAAAG,MAAAC,SAAAmI,KAAA,GAA2BC,QAAQ,CAAC7F,GAAD,CAAM;AACvC,MAAI6D,IAAI,IAAIxG,IAAAG,MAAAC,SAAZ;AACAoG,GAAAnE,QAAA,CAAUM,GAAV,CAAA;AACA,SAAO6D,CAAP;AAHuC,CAAzC;AAYA;;;AAAAxG,IAAAG,MAAAC,SAAAqI,SAAA,GAA+BC,QAAQ,EAAG;AACxC,MAAIlC,IAAI,IAAIxG,IAAAG,MAAAC,SAAZ;AACAoG,GAAA1E,OAAA,EAAA;AACA,SAAO0E,CAAP;AAHwC,CAA1C;AAuCA;;;;;;;AAAAxG,IAAAG,MAAAC,SAAAuI,KAAA,GAA2BC,QAAQ,CAACN,KAAD,EAAQpF,QAAR,EAAkBiB,SAAlB,CAA6B;AAC9D,MAAImE,KAAJ,YAAqBtI,IAAAG,MAAAC,SAArB;AACE,WAAOkI,KAAAjC,OAAA,CAAa,IAAb,CAAArC,YAAA,CAA+Bd,QAA/B,EAAyCiB,SAAzC,CAAP;AADF;AAGE,WAAOnE,IAAAG,MAAAC,SAAA8H,QAAA,CAA4BI,KAA5B,CAAAtE,YAAA,CAA+Cd,QAA/C,EAAyDiB,SAAzD,CAAP;AAHF;AAD8D,CAAhE;AAiBA;;;;;AAAAnE,IAAAG,MAAAC,SAAA6C,mBAAA,GAAyC4F,QAAQ,CAACC,QAAD,CAAW;AAC1D9I,MAAA+I,MAAAxH,MAAAa,KAAA,CAAsB,IAAtB,CAAA;AAMA,qCAAA,IAAA0G,SAAA,GAAgBA,QAAhB;AAP0D,CAA5D;AASA9I,IAAAgJ,SAAA,CAAchJ,IAAAG,MAAAC,SAAA6C,mBAAd,EAAsDjD,IAAA+I,MAAAxH,MAAtD,CAAA;AAIA,iBAAAvB,IAAAG,MAAAC,SAAA6C,mBAAApB,UAAAoH,QAAA,GACI,4BADJ;AAKA,iBAAAjJ,IAAAG,MAAAC,SAAA6C,mBAAApB,UAAAqH,KAAA,GAAwD,oBAAxD;AAWA;;;;;AAAAlJ,IAAAG,MAAAC,SAAAkC,cAAA,GAAoC6G,QAAQ,CAACL,QAAD,CAAW;AACrD9I,MAAA+I,MAAAxH,MAAAa,KAAA,CAAsB,IAAtB,CAAA;AAMA,qCAAA,IAAA0G,SAAA,GAAgBA,QAAhB;AAPqD,CAAvD;AASA9I,IAAAgJ,SAAA,CAAchJ,IAAAG,MAAAC,SAAAkC,cAAd,EAAiDtC,IAAA+I,MAAAxH,MAAjD,CAAA;AAIA,iBAAAvB,IAAAG,MAAAC,SAAAkC,cAAAT,UAAAoH,QAAA,GAAsD,uBAAtD;AAIA,iBAAAjJ,IAAAG,MAAAC,SAAAkC,cAAAT,UAAAqH,KAAA,GAAmD,eAAnD;AAcA;;;;;;;AAAAlJ,IAAAG,MAAAC,SAAAgJ,OAAA,GAA6BC,QAAQ,CAAC5F,KAAD,CAAQ;AAE3C,wCAAA,IAAA6F,IAAA,GAAWtJ,IAAA4H,OAAA2B,WAAA,CAAuBvJ,IAAAoG,KAAA,CAAU,IAAAoD,WAAV,EAA2B,IAA3B,CAAvB,EAAyD,CAAzD,CAAX;AAGA,mCAAA,IAAAC,OAAA,GAAchG,KAAd;AAL2C,CAA7C;AAaAzD,IAAAG,MAAAC,SAAAgJ,OAAAvH,UAAA2H,WAAA,GAAkDE,QAAQ,EAAG;AAC3D1J,MAAA8D,QAAAC,OAAA,CAAoB/D,IAAAG,MAAAC,SAAAuJ,UAAA,CAA8B,IAAAL,IAA9B,CAApB,EACI,8CADJ,CAAA;AAEA,SAAOtJ,IAAAG,MAAAC,SAAAuJ,UAAA,CAA8B,IAAAL,IAA9B,CAAP;AACA,QAAM,IAAAG,OAAN;AAJ2D,CAA7D;AAWAzJ,IAAAG,MAAAC,SAAAgJ,OAAAvH,UAAA+H,WAAA,GAAkDC,QAAQ,EAAG;AAC3D7J,MAAA4H,OAAAkC,aAAA,CAAyB,IAAAR,IAAzB,CAAA;AAD2D,CAA7D;AASA,4EAAAtJ,IAAAG,MAAAC,SAAAuJ,UAAA,GAAgC,EAAhC;AASA;;;;;AAAA3J,IAAAG,MAAAC,SAAA6H,eAAA,GAAqC8B,QAAQ,CAACtG,KAAD,CAAQ;AACnD,MAAIuG,gBAAgB,IAAIhK,IAAAG,MAAAC,SAAAgJ,OAAJ,CAA+B3F,KAA/B,CAApB;AACAzD,MAAAG,MAAAC,SAAAuJ,UAAA,CAA8BK,aAAAV,IAA9B,CAAA,GAAmDU,aAAnD;AACA,SAAOA,aAAAV,IAAP;AAHmD,CAArD;AAYA;;;;AAAAtJ,IAAAG,MAAAC,SAAA+G,iBAAA,GAAuC8C,QAAQ,CAACC,EAAD,CAAK;AAClD,MAAIzG,QAAQzD,IAAAG,MAAAC,SAAAuJ,UAAA,CAA8BO,EAA9B,CAAZ;AACA,MAAIzG,KAAJ,CAAW;AACTA,SAAAmG,WAAA,EAAA;AACA,WAAO5J,IAAAG,MAAAC,SAAAuJ,UAAA,CAA8BO,EAA9B,CAAP;AAFS;AAFuC,CAApD;AAaAlK,IAAAG,MAAAC,SAAA+J,eAAA,GAAqCC,QAAQ,EAAG;AAC9C,MAAIC,MAAMrK,IAAAG,MAAAC,SAAAuJ,UAAV;AACA,OAAK,IAAIW,GAAT,GAAgBD,IAAhB,CAAqB;AACnB,QAAI5G,QAAQ4G,GAAA,CAAIC,GAAJ,CAAZ;AACA7G,SAAAmG,WAAA,EAAA;AACAnG,SAAA+F,WAAA,EAAA;AAHmB;AAFyB,CAAhD;;\",\n\"sources\":[\"goog/mochikit/async/deferred.js\"],\n\"sourcesContent\":[\"// Copyright 2007 Bob Ippolito. All Rights Reserved.\\n// Modifications Copyright 2009 The Closure Library Authors. All Rights\\n// Reserved.\\n\\n/**\\n * @license Portions of this code are from MochiKit, received by\\n * The Closure Authors under the MIT license. All other code is Copyright\\n * 2005-2009 The Closure Authors. All Rights Reserved.\\n */\\n\\n/**\\n * @fileoverview Classes for tracking asynchronous operations and handling the\\n * results. The Deferred object here is patterned after the Deferred object in\\n * the Twisted python networking framework.\\n *\\n * See: http://twistedmatrix.com/projects/core/documentation/howto/defer.html\\n *\\n * Based on the Dojo code which in turn is based on the MochiKit code.\\n *\\n * @author arv@google.com (Erik Arvidsson)\\n * @author brenneman@google.com (Shawn Brenneman)\\n */\\n\\ngoog.provide('goog.async.Deferred');\\ngoog.provide('goog.async.Deferred.AlreadyCalledError');\\ngoog.provide('goog.async.Deferred.CanceledError');\\n\\ngoog.require('goog.Promise');\\ngoog.require('goog.Thenable');\\ngoog.require('goog.array');\\ngoog.require('goog.asserts');\\ngoog.require('goog.debug.Error');\\n\\n\\n\\n/**\\n * A Deferred represents the result of an asynchronous operation. A Deferred\\n * instance has no result when it is created, and is \\\"fired\\\" (given an initial\\n * result) by calling `callback` or `errback`.\\n *\\n * Once fired, the result is passed through a sequence of callback functions\\n * registered with `addCallback` or `addErrback`. The functions may\\n * mutate the result before it is passed to the next function in the sequence.\\n *\\n * Callbacks and errbacks may be added at any time, including after the Deferred\\n * has been \\\"fired\\\". If there are no pending actions in the execution sequence\\n * of a fired Deferred, any new callback functions will be called with the last\\n * computed result. Adding a callback function is the only way to access the\\n * result of the Deferred.\\n *\\n * If a Deferred operation is canceled, an optional user-provided cancellation\\n * function is invoked which may perform any special cleanup, followed by firing\\n * the Deferred's errback sequence with a `CanceledError`. If the\\n * Deferred has already fired, cancellation is ignored.\\n *\\n * Deferreds may be templated to a specific type they produce using generics\\n * with syntax such as:\\n *\\n *    /** @type {goog.async.Deferred<string>} *\\\\\\n *    var d = new goog.async.Deferred();\\n *    // Compiler can infer that foo is a string.\\n *    d.addCallback(function(foo) {...});\\n *    d.callback('string');  // Checked to be passed a string\\n *\\n * Since deferreds are often used to produce different values across a chain,\\n * the type information is not propagated across chains, but rather only\\n * associated with specifically cast objects.\\n *\\n * @param {Function=} opt_onCancelFunction A function that will be called if the\\n *     Deferred is canceled. If provided, this function runs before the\\n *     Deferred is fired with a `CanceledError`.\\n * @param {Object=} opt_defaultScope The default object context to call\\n *     callbacks and errbacks in.\\n * @constructor\\n * @implements {goog.Thenable<VALUE>}\\n * @template VALUE\\n */\\ngoog.async.Deferred = function(opt_onCancelFunction, opt_defaultScope) {\\n  /**\\n   * Entries in the sequence are arrays containing a callback, an errback, and\\n   * an optional scope. The callback or errback in an entry may be null.\\n   * @type {!Array<!Array>}\\n   * @private\\n   */\\n  this.sequence_ = [];\\n\\n  /**\\n   * Optional function that will be called if the Deferred is canceled.\\n   * @type {Function|undefined}\\n   * @private\\n   */\\n  this.onCancelFunction_ = opt_onCancelFunction;\\n\\n  /**\\n   * The default scope to execute callbacks and errbacks in.\\n   * @type {Object}\\n   * @private\\n   */\\n  this.defaultScope_ = opt_defaultScope || null;\\n\\n  /**\\n   * Whether the Deferred has been fired.\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.fired_ = false;\\n\\n  /**\\n   * Whether the last result in the execution sequence was an error.\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.hadError_ = false;\\n\\n  /**\\n   * The current Deferred result, updated as callbacks and errbacks are\\n   * executed.\\n   * @type {*}\\n   * @private\\n   */\\n  this.result_ = undefined;\\n\\n  /**\\n   * Whether the Deferred is blocked waiting on another Deferred to fire. If a\\n   * callback or errback returns a Deferred as a result, the execution sequence\\n   * is blocked until that Deferred result becomes available.\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.blocked_ = false;\\n\\n  /**\\n   * Whether this Deferred is blocking execution of another Deferred. If this\\n   * instance was returned as a result in another Deferred's execution\\n   * sequence,that other Deferred becomes blocked until this instance's\\n   * execution sequence completes. No additional callbacks may be added to a\\n   * Deferred once it is blocking another instance.\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.blocking_ = false;\\n\\n  /**\\n   * Whether the Deferred has been canceled without having a custom cancel\\n   * function.\\n   * @type {boolean}\\n   * @private\\n   */\\n  this.silentlyCanceled_ = false;\\n\\n  /**\\n   * If an error is thrown during Deferred execution with no errback to catch\\n   * it, the error is rethrown after a timeout. Reporting the error after a\\n   * timeout allows execution to continue in the calling context (empty when\\n   * no error is scheduled).\\n   * @type {number}\\n   * @private\\n   */\\n  this.unhandledErrorId_ = 0;\\n\\n  /**\\n   * If this Deferred was created by branch(), this will be the \\\"parent\\\"\\n   * Deferred.\\n   * @type {?goog.async.Deferred}\\n   * @private\\n   */\\n  this.parent_ = null;\\n\\n  /**\\n   * The number of Deferred objects that have been branched off this one. This\\n   * will be decremented whenever a branch is fired or canceled.\\n   * @type {number}\\n   * @private\\n   */\\n  this.branches_ = 0;\\n\\n  if (goog.async.Deferred.LONG_STACK_TRACES) {\\n    /**\\n     * Holds the stack trace at time of deferred creation if the JS engine\\n     * provides the Error.captureStackTrace API.\\n     * @private {?string}\\n     */\\n    this.constructorStack_ = null;\\n    if (Error.captureStackTrace) {\\n      var target = { stack: '' };\\n      Error.captureStackTrace(target, goog.async.Deferred);\\n      // Check if Error.captureStackTrace worked. It fails in gjstest.\\n      if (typeof target.stack == 'string') {\\n        // Remove first line and force stringify to prevent memory leak due to\\n        // holding on to actual stack frames.\\n        this.constructorStack_ = target.stack.replace(/^[^\\\\n]*\\\\n/, '');\\n      }\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @define {boolean} Whether unhandled errors should always get rethrown to the\\n * global scope. Defaults to false.\\n */\\ngoog.define('goog.async.Deferred.STRICT_ERRORS', false);\\n\\n\\n/**\\n * @define {boolean} Whether to attempt to make stack traces long.  Defaults to\\n * false.\\n */\\ngoog.define('goog.async.Deferred.LONG_STACK_TRACES', false);\\n\\n\\n/**\\n * Cancels a Deferred that has not yet been fired, or is blocked on another\\n * deferred operation. If this Deferred is waiting for a blocking Deferred to\\n * fire, the blocking Deferred will also be canceled.\\n *\\n * If this Deferred was created by calling branch() on a parent Deferred with\\n * opt_propagateCancel set to true, the parent may also be canceled. If\\n * opt_deepCancel is set, cancel() will be called on the parent (as well as any\\n * other ancestors if the parent is also a branch). If one or more branches were\\n * created with opt_propagateCancel set to true, the parent will be canceled if\\n * cancel() is called on all of those branches.\\n *\\n * @param {boolean=} opt_deepCancel If true, cancels this Deferred's parent even\\n *     if cancel() hasn't been called on some of the parent's branches. Has no\\n *     effect on a branch without opt_propagateCancel set to true.\\n */\\ngoog.async.Deferred.prototype.cancel = function(opt_deepCancel) {\\n  if (!this.hasFired()) {\\n    if (this.parent_) {\\n      // Get rid of the parent reference before potentially running the parent's\\n      // canceler function to ensure that this cancellation isn't\\n      // double-counted.\\n      var parent = this.parent_;\\n      delete this.parent_;\\n      if (opt_deepCancel) {\\n        parent.cancel(opt_deepCancel);\\n      } else {\\n        parent.branchCancel_();\\n      }\\n    }\\n\\n    if (this.onCancelFunction_) {\\n      // Call in user-specified scope.\\n      this.onCancelFunction_.call(this.defaultScope_, this);\\n    } else {\\n      this.silentlyCanceled_ = true;\\n    }\\n    if (!this.hasFired()) {\\n      this.errback(new goog.async.Deferred.CanceledError(this));\\n    }\\n  } else if (this.result_ instanceof goog.async.Deferred) {\\n    this.result_.cancel();\\n  }\\n};\\n\\n\\n/**\\n * Handle a single branch being canceled. Once all branches are canceled, this\\n * Deferred will be canceled as well.\\n *\\n * @private\\n */\\ngoog.async.Deferred.prototype.branchCancel_ = function() {\\n  this.branches_--;\\n  if (this.branches_ <= 0) {\\n    this.cancel();\\n  }\\n};\\n\\n\\n/**\\n * Called after a blocking Deferred fires. Unblocks this Deferred and resumes\\n * its execution sequence.\\n *\\n * @param {boolean} isSuccess Whether the result is a success or an error.\\n * @param {*} res The result of the blocking Deferred.\\n * @private\\n */\\ngoog.async.Deferred.prototype.continue_ = function(isSuccess, res) {\\n  this.blocked_ = false;\\n  this.updateResult_(isSuccess, res);\\n};\\n\\n\\n/**\\n * Updates the current result based on the success or failure of the last action\\n * in the execution sequence.\\n *\\n * @param {boolean} isSuccess Whether the new result is a success or an error.\\n * @param {*} res The result.\\n * @private\\n */\\ngoog.async.Deferred.prototype.updateResult_ = function(isSuccess, res) {\\n  this.fired_ = true;\\n  this.result_ = res;\\n  this.hadError_ = !isSuccess;\\n  this.fire_();\\n};\\n\\n\\n/**\\n * Verifies that the Deferred has not yet been fired.\\n *\\n * @private\\n * @throws {Error} If this has already been fired.\\n */\\ngoog.async.Deferred.prototype.check_ = function() {\\n  if (this.hasFired()) {\\n    if (!this.silentlyCanceled_) {\\n      throw new goog.async.Deferred.AlreadyCalledError(this);\\n    }\\n    this.silentlyCanceled_ = false;\\n  }\\n};\\n\\n\\n/**\\n * Fire the execution sequence for this Deferred by passing the starting result\\n * to the first registered callback.\\n * @param {VALUE=} opt_result The starting result.\\n */\\ngoog.async.Deferred.prototype.callback = function(opt_result) {\\n  this.check_();\\n  this.assertNotDeferred_(opt_result);\\n  this.updateResult_(true /* isSuccess */, opt_result);\\n};\\n\\n\\n/**\\n * Fire the execution sequence for this Deferred by passing the starting error\\n * result to the first registered errback.\\n * @param {*=} opt_result The starting error.\\n */\\ngoog.async.Deferred.prototype.errback = function(opt_result) {\\n  this.check_();\\n  this.assertNotDeferred_(opt_result);\\n  this.makeStackTraceLong_(opt_result);\\n  this.updateResult_(false /* isSuccess */, opt_result);\\n};\\n\\n\\n/**\\n * Attempt to make the error's stack trace be long in that it contains the\\n * stack trace from the point where the deferred was created on top of the\\n * current stack trace to give additional context.\\n * @param {*} error\\n * @private\\n */\\ngoog.async.Deferred.prototype.makeStackTraceLong_ = function(error) {\\n  if (!goog.async.Deferred.LONG_STACK_TRACES) {\\n    return;\\n  }\\n  if (this.constructorStack_ && goog.isObject(error) && error.stack &&\\n      // Stack looks like it was system generated. See\\n      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\\n      (/^[^\\\\n]+(\\\\n   [^\\\\n]+)+/).test(error.stack)) {\\n    error.stack = error.stack + '\\\\nDEFERRED OPERATION:\\\\n' +\\n        this.constructorStack_;\\n  }\\n};\\n\\n\\n/**\\n * Asserts that an object is not a Deferred.\\n * @param {*} obj The object to test.\\n * @throws {Error} Throws an exception if the object is a Deferred.\\n * @private\\n */\\ngoog.async.Deferred.prototype.assertNotDeferred_ = function(obj) {\\n  goog.asserts.assert(\\n      !(obj instanceof goog.async.Deferred),\\n      'An execution sequence may not be initiated with a blocking Deferred.');\\n};\\n\\n\\n/**\\n * Register a callback function to be called with a successful result. If no\\n * value is returned by the callback function, the result value is unchanged. If\\n * a new value is returned, it becomes the Deferred result and will be passed to\\n * the next callback in the execution sequence.\\n *\\n * If the function throws an error, the error becomes the new result and will be\\n * passed to the next errback in the execution chain.\\n *\\n * If the function returns a Deferred, the execution sequence will be blocked\\n * until that Deferred fires. Its result will be passed to the next callback (or\\n * errback if it is an error result) in this Deferred's execution sequence.\\n *\\n * @param {function(this:T,VALUE):?} cb The function to be called with a\\n *     successful result.\\n * @param {T=} opt_scope An optional scope to call the callback in.\\n * @return {!goog.async.Deferred} This Deferred.\\n * @template T\\n */\\ngoog.async.Deferred.prototype.addCallback = function(cb, opt_scope) {\\n  return this.addCallbacks(cb, null, opt_scope);\\n};\\n\\n\\n/**\\n * Register a callback function to be called with an error result. If no value\\n * is returned by the function, the error result is unchanged. If a new error\\n * value is returned or thrown, that error becomes the Deferred result and will\\n * be passed to the next errback in the execution sequence.\\n *\\n * If the errback function handles the error by returning a non-error value,\\n * that result will be passed to the next normal callback in the sequence.\\n *\\n * If the function returns a Deferred, the execution sequence will be blocked\\n * until that Deferred fires. Its result will be passed to the next callback (or\\n * errback if it is an error result) in this Deferred's execution sequence.\\n *\\n * @param {function(this:T,?):?} eb The function to be called on an\\n *     unsuccessful result.\\n * @param {T=} opt_scope An optional scope to call the errback in.\\n * @return {!goog.async.Deferred<VALUE>} This Deferred.\\n * @template T\\n */\\ngoog.async.Deferred.prototype.addErrback = function(eb, opt_scope) {\\n  return this.addCallbacks(null, eb, opt_scope);\\n};\\n\\n\\n/**\\n * Registers one function as both a callback and errback.\\n *\\n * @param {function(this:T,?):?} f The function to be called on any result.\\n * @param {T=} opt_scope An optional scope to call the function in.\\n * @return {!goog.async.Deferred} This Deferred.\\n * @template T\\n */\\ngoog.async.Deferred.prototype.addBoth = function(f, opt_scope) {\\n  return this.addCallbacks(f, f, opt_scope);\\n};\\n\\n\\n/**\\n * Like addBoth, but propagates uncaught exceptions in the errback.\\n *\\n * @param {function(this:T,?):?} f The function to be called on any result.\\n * @param {T=} opt_scope An optional scope to call the function in.\\n * @return {!goog.async.Deferred<VALUE>} This Deferred.\\n * @template T\\n */\\ngoog.async.Deferred.prototype.addFinally = function(f, opt_scope) {\\n  return this.addCallbacks(f, function(err) {\\n    var result = f.call(/** @type {?} */ (this), err);\\n    if (!goog.isDef(result)) {\\n      throw err;\\n    }\\n    return result;\\n  }, opt_scope);\\n};\\n\\n\\n/**\\n * Registers a callback function and an errback function at the same position\\n * in the execution sequence. Only one of these functions will execute,\\n * depending on the error state during the execution sequence.\\n *\\n * NOTE: This is not equivalent to {@code def.addCallback().addErrback()}! If\\n * the callback is invoked, the errback will be skipped, and vice versa.\\n *\\n * @param {?(function(this:T,VALUE):?)} cb The function to be called on a\\n *     successful result.\\n * @param {?(function(this:T,?):?)} eb The function to be called on an\\n *     unsuccessful result.\\n * @param {T=} opt_scope An optional scope to call the functions in.\\n * @return {!goog.async.Deferred} This Deferred.\\n * @template T\\n */\\ngoog.async.Deferred.prototype.addCallbacks = function(cb, eb, opt_scope) {\\n  goog.asserts.assert(!this.blocking_, 'Blocking Deferreds can not be re-used');\\n  this.sequence_.push([cb, eb, opt_scope]);\\n  if (this.hasFired()) {\\n    this.fire_();\\n  }\\n  return this;\\n};\\n\\n\\n/**\\n * Implements {@see goog.Thenable} for seamless integration with\\n * {@see goog.Promise}.\\n * Deferred results are mutable and may represent multiple values over\\n * their lifetime. Calling `then` on a Deferred returns a Promise\\n * with the result of the Deferred at that point in its callback chain.\\n * Note that if the Deferred result is never mutated, and only\\n * `then` calls are made, the Deferred will behave like a Promise.\\n *\\n * @override\\n */\\ngoog.async.Deferred.prototype.then = function(opt_onFulfilled, opt_onRejected,\\n    opt_context) {\\n  var resolve, reject;\\n  var promise = new goog.Promise(function(res, rej) {\\n    // Copying resolvers to outer scope, so that they are available when the\\n    // deferred callback fires (which may be synchronous).\\n    resolve = res;\\n    reject = rej;\\n  });\\n  this.addCallbacks(resolve, function(reason) {\\n    if (reason instanceof goog.async.Deferred.CanceledError) {\\n      promise.cancel();\\n    } else {\\n      reject(reason);\\n    }\\n  });\\n  return promise.then(opt_onFulfilled, opt_onRejected, opt_context);\\n};\\ngoog.Thenable.addImplementation(goog.async.Deferred);\\n\\n\\n/**\\n * Links another Deferred to the end of this Deferred's execution sequence. The\\n * result of this execution sequence will be passed as the starting result for\\n * the chained Deferred, invoking either its first callback or errback.\\n *\\n * @param {!goog.async.Deferred} otherDeferred The Deferred to chain.\\n * @return {!goog.async.Deferred} This Deferred.\\n */\\ngoog.async.Deferred.prototype.chainDeferred = function(otherDeferred) {\\n  this.addCallbacks(\\n      otherDeferred.callback, otherDeferred.errback, otherDeferred);\\n  return this;\\n};\\n\\n\\n/**\\n * Makes this Deferred wait for another Deferred's execution sequence to\\n * complete before continuing.\\n *\\n * This is equivalent to adding a callback that returns `otherDeferred`,\\n * but doesn't prevent additional callbacks from being added to\\n * `otherDeferred`.\\n *\\n * @param {!goog.async.Deferred|!goog.Thenable} otherDeferred The Deferred\\n *     to wait for.\\n * @return {!goog.async.Deferred} This Deferred.\\n */\\ngoog.async.Deferred.prototype.awaitDeferred = function(otherDeferred) {\\n  if (!(otherDeferred instanceof goog.async.Deferred)) {\\n    // The Thenable case.\\n    return this.addCallback(function() {\\n      return otherDeferred;\\n    });\\n  }\\n  return this.addCallback(goog.bind(otherDeferred.branch, otherDeferred));\\n};\\n\\n\\n/**\\n * Creates a branch off this Deferred's execution sequence, and returns it as a\\n * new Deferred. The branched Deferred's starting result will be shared with the\\n * parent at the point of the branch, even if further callbacks are added to the\\n * parent.\\n *\\n * All branches at the same stage in the execution sequence will receive the\\n * same starting value.\\n *\\n * @param {boolean=} opt_propagateCancel If cancel() is called on every child\\n *     branch created with opt_propagateCancel, the parent will be canceled as\\n *     well.\\n * @return {!goog.async.Deferred<VALUE>} A Deferred that will be started with\\n *     the computed result from this stage in the execution sequence.\\n */\\ngoog.async.Deferred.prototype.branch = function(opt_propagateCancel) {\\n  var d = new goog.async.Deferred();\\n  this.chainDeferred(d);\\n  if (opt_propagateCancel) {\\n    d.parent_ = this;\\n    this.branches_++;\\n  }\\n  return d;\\n};\\n\\n\\n/**\\n * @return {boolean} Whether the execution sequence has been started on this\\n *     Deferred by invoking `callback` or `errback`.\\n */\\ngoog.async.Deferred.prototype.hasFired = function() {\\n  return this.fired_;\\n};\\n\\n\\n/**\\n * @param {*} res The latest result in the execution sequence.\\n * @return {boolean} Whether the current result is an error that should cause\\n *     the next errback to fire. May be overridden by subclasses to handle\\n *     special error types.\\n * @protected\\n */\\ngoog.async.Deferred.prototype.isError = function(res) {\\n  return res instanceof Error;\\n};\\n\\n\\n/**\\n * @return {boolean} Whether an errback exists in the remaining sequence.\\n * @private\\n */\\ngoog.async.Deferred.prototype.hasErrback_ = function() {\\n  return goog.array.some(this.sequence_, function(sequenceRow) {\\n    // The errback is the second element in the array.\\n    return goog.isFunction(sequenceRow[1]);\\n  });\\n};\\n\\n\\n/**\\n * Exhausts the execution sequence while a result is available. The result may\\n * be modified by callbacks or errbacks, and execution will block if the\\n * returned result is an incomplete Deferred.\\n *\\n * @private\\n */\\ngoog.async.Deferred.prototype.fire_ = function() {\\n  if (this.unhandledErrorId_ && this.hasFired() && this.hasErrback_()) {\\n    // It is possible to add errbacks after the Deferred has fired. If a new\\n    // errback is added immediately after the Deferred encountered an unhandled\\n    // error, but before that error is rethrown, the error is unscheduled.\\n    goog.async.Deferred.unscheduleError_(this.unhandledErrorId_);\\n    this.unhandledErrorId_ = 0;\\n  }\\n\\n  if (this.parent_) {\\n    this.parent_.branches_--;\\n    delete this.parent_;\\n  }\\n\\n  var res = this.result_;\\n  var unhandledException = false;\\n  var isNewlyBlocked = false;\\n\\n  while (this.sequence_.length && !this.blocked_) {\\n    var sequenceEntry = this.sequence_.shift();\\n\\n    var callback = sequenceEntry[0];\\n    var errback = sequenceEntry[1];\\n    var scope = sequenceEntry[2];\\n\\n    var f = this.hadError_ ? errback : callback;\\n    if (f) {\\n\\n      try {\\n        var ret = f.call(scope || this.defaultScope_, res);\\n\\n        // If no result, then use previous result.\\n        if (goog.isDef(ret)) {\\n          // Bubble up the error as long as the return value hasn't changed.\\n          this.hadError_ = this.hadError_ && (ret == res || this.isError(ret));\\n          this.result_ = res = ret;\\n        }\\n\\n        if (goog.Thenable.isImplementedBy(res) ||\\n            (typeof goog.global['Promise'] === 'function' &&\\n            res instanceof goog.global['Promise'])) {\\n          isNewlyBlocked = true;\\n          this.blocked_ = true;\\n        }\\n\\n      } catch (ex) {\\n        res = ex;\\n        this.hadError_ = true;\\n        this.makeStackTraceLong_(res);\\n\\n        if (!this.hasErrback_()) {\\n          // If an error is thrown with no additional errbacks in the queue,\\n          // prepare to rethrow the error.\\n          unhandledException = true;\\n        }\\n      }\\n    }\\n  }\\n\\n  this.result_ = res;\\n\\n  if (isNewlyBlocked) {\\n    var onCallback = goog.bind(this.continue_, this, true /* isSuccess */);\\n    var onErrback = goog.bind(this.continue_, this, false /* isSuccess */);\\n\\n    if (res instanceof goog.async.Deferred) {\\n      res.addCallbacks(onCallback, onErrback);\\n      res.blocking_ = true;\\n    } else {\\n      /** @type {!IThenable} */ (res).then(onCallback, onErrback);\\n    }\\n  } else if (goog.async.Deferred.STRICT_ERRORS && this.isError(res) &&\\n      !(res instanceof goog.async.Deferred.CanceledError)) {\\n    this.hadError_ = true;\\n    unhandledException = true;\\n  }\\n\\n  if (unhandledException) {\\n    // Rethrow the unhandled error after a timeout. Execution will continue, but\\n    // the error will be seen by global handlers and the user. The throw will\\n    // be canceled if another errback is appended before the timeout executes.\\n    // The error's original stack trace is preserved where available.\\n    this.unhandledErrorId_ = goog.async.Deferred.scheduleError_(res);\\n  }\\n};\\n\\n\\n/**\\n * Creates a Deferred that has an initial result.\\n *\\n * @param {*=} opt_result The result.\\n * @return {!goog.async.Deferred} The new Deferred.\\n */\\ngoog.async.Deferred.succeed = function(opt_result) {\\n  var d = new goog.async.Deferred();\\n  d.callback(opt_result);\\n  return d;\\n};\\n\\n\\n/**\\n * Creates a Deferred that fires when the given promise resolves.\\n * Use only during migration to Promises.\\n *\\n * Note: If the promise resolves to a thenable value (which is not allowed by\\n * conforming promise implementations), then the deferred may behave\\n * unexpectedly as it tries to wait on it. This should not be a risk when using\\n * goog.Promise, goog.async.Deferred, or native Promise objects.\\n *\\n * @param {!IThenable<T>} promise\\n * @return {!goog.async.Deferred<T>} The new Deferred.\\n * @template T\\n */\\ngoog.async.Deferred.fromPromise = function(promise) {\\n  var d = new goog.async.Deferred();\\n  promise.then(\\n      function(value) {\\n        d.callback(value);\\n      },\\n      function(error) {\\n        d.errback(error);\\n      });\\n  return d;\\n};\\n\\n\\n/**\\n * Creates a Deferred that has an initial error result.\\n *\\n * @param {*} res The error result.\\n * @return {!goog.async.Deferred} The new Deferred.\\n */\\ngoog.async.Deferred.fail = function(res) {\\n  var d = new goog.async.Deferred();\\n  d.errback(res);\\n  return d;\\n};\\n\\n\\n/**\\n * Creates a Deferred that has already been canceled.\\n *\\n * @return {!goog.async.Deferred} The new Deferred.\\n */\\ngoog.async.Deferred.canceled = function() {\\n  var d = new goog.async.Deferred();\\n  d.cancel();\\n  return d;\\n};\\n\\n\\n/**\\n * Normalizes values that may or may not be Deferreds.\\n *\\n * If the input value is a Deferred, the Deferred is branched (so the original\\n * execution sequence is not modified) and the input callback added to the new\\n * branch. The branch is returned to the caller.\\n *\\n * If the input value is not a Deferred, the callback will be executed\\n * immediately and an already firing Deferred will be returned to the caller.\\n *\\n * In the following (contrived) example, if <code>isImmediate</code> is true\\n * then 3 is alerted immediately, otherwise 6 is alerted after a 2-second delay.\\n *\\n * <pre>\\n * var value;\\n * if (isImmediate) {\\n *   value = 3;\\n * } else {\\n *   value = new goog.async.Deferred();\\n *   setTimeout(function() { value.callback(6); }, 2000);\\n * }\\n *\\n * var d = goog.async.Deferred.when(value, alert);\\n * </pre>\\n *\\n * @param {*} value Deferred or normal value to pass to the callback.\\n * @param {function(this:T, ?):?} callback The callback to execute.\\n * @param {T=} opt_scope An optional scope to call the callback in.\\n * @return {!goog.async.Deferred} A new Deferred that will call the input\\n *     callback with the input value.\\n * @template T\\n */\\ngoog.async.Deferred.when = function(value, callback, opt_scope) {\\n  if (value instanceof goog.async.Deferred) {\\n    return value.branch(true).addCallback(callback, opt_scope);\\n  } else {\\n    return goog.async.Deferred.succeed(value).addCallback(callback, opt_scope);\\n  }\\n};\\n\\n\\n\\n/**\\n * An error sub class that is used when a Deferred has already been called.\\n * @param {!goog.async.Deferred} deferred The Deferred.\\n *\\n * @constructor\\n * @extends {goog.debug.Error}\\n */\\ngoog.async.Deferred.AlreadyCalledError = function(deferred) {\\n  goog.debug.Error.call(this);\\n\\n  /**\\n   * The Deferred that raised this error.\\n   * @type {goog.async.Deferred}\\n   */\\n  this.deferred = deferred;\\n};\\ngoog.inherits(goog.async.Deferred.AlreadyCalledError, goog.debug.Error);\\n\\n\\n/** @override */\\ngoog.async.Deferred.AlreadyCalledError.prototype.message =\\n    'Deferred has already fired';\\n\\n\\n/** @override */\\ngoog.async.Deferred.AlreadyCalledError.prototype.name = 'AlreadyCalledError';\\n\\n\\n\\n/**\\n * An error sub class that is used when a Deferred is canceled.\\n *\\n * @param {!goog.async.Deferred} deferred The Deferred object.\\n * @constructor\\n * @extends {goog.debug.Error}\\n */\\ngoog.async.Deferred.CanceledError = function(deferred) {\\n  goog.debug.Error.call(this);\\n\\n  /**\\n   * The Deferred that raised this error.\\n   * @type {goog.async.Deferred}\\n   */\\n  this.deferred = deferred;\\n};\\ngoog.inherits(goog.async.Deferred.CanceledError, goog.debug.Error);\\n\\n\\n/** @override */\\ngoog.async.Deferred.CanceledError.prototype.message = 'Deferred was canceled';\\n\\n\\n/** @override */\\ngoog.async.Deferred.CanceledError.prototype.name = 'CanceledError';\\n\\n\\n\\n/**\\n * Wrapper around errors that are scheduled to be thrown by failing deferreds\\n * after a timeout.\\n *\\n * @param {*} error Error from a failing deferred.\\n * @constructor\\n * @final\\n * @private\\n * @struct\\n */\\ngoog.async.Deferred.Error_ = function(error) {\\n  /** @const @private {number} */\\n  this.id_ = goog.global.setTimeout(goog.bind(this.throwError, this), 0);\\n\\n  /** @const @private {*} */\\n  this.error_ = error;\\n};\\n\\n\\n/**\\n * Actually throws the error and removes it from the list of pending\\n * deferred errors.\\n */\\ngoog.async.Deferred.Error_.prototype.throwError = function() {\\n  goog.asserts.assert(goog.async.Deferred.errorMap_[this.id_],\\n      'Cannot throw an error that is not scheduled.');\\n  delete goog.async.Deferred.errorMap_[this.id_];\\n  throw this.error_;\\n};\\n\\n\\n/**\\n * Resets the error throw timer.\\n */\\ngoog.async.Deferred.Error_.prototype.resetTimer = function() {\\n  goog.global.clearTimeout(this.id_);\\n};\\n\\n\\n/**\\n * Map of unhandled errors scheduled to be rethrown in a future timestep.\\n * @private {!Object<(number|string), goog.async.Deferred.Error_>}\\n */\\ngoog.async.Deferred.errorMap_ = {};\\n\\n\\n/**\\n * Schedules an error to be thrown after a delay.\\n * @param {*} error Error from a failing deferred.\\n * @return {number} Id of the error.\\n * @private\\n */\\ngoog.async.Deferred.scheduleError_ = function(error) {\\n  var deferredError = new goog.async.Deferred.Error_(error);\\n  goog.async.Deferred.errorMap_[deferredError.id_] = deferredError;\\n  return deferredError.id_;\\n};\\n\\n\\n/**\\n * Unschedules an error from being thrown.\\n * @param {number} id Id of the deferred error to unschedule.\\n * @private\\n */\\ngoog.async.Deferred.unscheduleError_ = function(id) {\\n  var error = goog.async.Deferred.errorMap_[id];\\n  if (error) {\\n    error.resetTimer();\\n    delete goog.async.Deferred.errorMap_[id];\\n  }\\n};\\n\\n\\n/**\\n * Asserts that there are no pending deferred errors. If there are any\\n * scheduled errors, one will be thrown immediately to make this function fail.\\n */\\ngoog.async.Deferred.assertNoErrors = function() {\\n  var map = goog.async.Deferred.errorMap_;\\n  for (var key in map) {\\n    var error = map[key];\\n    error.resetTimer();\\n    error.throwError();\\n  }\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"async\",\"Deferred\",\"goog.async.Deferred\",\"opt_onCancelFunction\",\"opt_defaultScope\",\"sequence_\",\"onCancelFunction_\",\"defaultScope_\",\"fired_\",\"hadError_\",\"result_\",\"undefined\",\"blocked_\",\"blocking_\",\"silentlyCanceled_\",\"unhandledErrorId_\",\"parent_\",\"branches_\",\"LONG_STACK_TRACES\",\"constructorStack_\",\"Error\",\"captureStackTrace\",\"target\",\"stack\",\"replace\",\"define\",\"prototype\",\"cancel\",\"goog.async.Deferred.prototype.cancel\",\"opt_deepCancel\",\"hasFired\",\"parent\",\"branchCancel_\",\"call\",\"errback\",\"CanceledError\",\"goog.async.Deferred.prototype.branchCancel_\",\"continue_\",\"goog.async.Deferred.prototype.continue_\",\"isSuccess\",\"res\",\"updateResult_\",\"goog.async.Deferred.prototype.updateResult_\",\"fire_\",\"check_\",\"goog.async.Deferred.prototype.check_\",\"AlreadyCalledError\",\"callback\",\"goog.async.Deferred.prototype.callback\",\"opt_result\",\"assertNotDeferred_\",\"goog.async.Deferred.prototype.errback\",\"makeStackTraceLong_\",\"goog.async.Deferred.prototype.makeStackTraceLong_\",\"error\",\"isObject\",\"test\",\"goog.async.Deferred.prototype.assertNotDeferred_\",\"obj\",\"asserts\",\"assert\",\"addCallback\",\"goog.async.Deferred.prototype.addCallback\",\"cb\",\"opt_scope\",\"addCallbacks\",\"addErrback\",\"goog.async.Deferred.prototype.addErrback\",\"eb\",\"addBoth\",\"goog.async.Deferred.prototype.addBoth\",\"f\",\"addFinally\",\"goog.async.Deferred.prototype.addFinally\",\"err\",\"result\",\"isDef\",\"goog.async.Deferred.prototype.addCallbacks\",\"push\",\"then\",\"goog.async.Deferred.prototype.then\",\"opt_onFulfilled\",\"opt_onRejected\",\"opt_context\",\"resolve\",\"reject\",\"promise\",\"Promise\",\"rej\",\"reason\",\"Thenable\",\"addImplementation\",\"chainDeferred\",\"goog.async.Deferred.prototype.chainDeferred\",\"otherDeferred\",\"awaitDeferred\",\"goog.async.Deferred.prototype.awaitDeferred\",\"bind\",\"branch\",\"goog.async.Deferred.prototype.branch\",\"opt_propagateCancel\",\"d\",\"goog.async.Deferred.prototype.hasFired\",\"isError\",\"goog.async.Deferred.prototype.isError\",\"hasErrback_\",\"goog.async.Deferred.prototype.hasErrback_\",\"array\",\"some\",\"sequenceRow\",\"isFunction\",\"goog.async.Deferred.prototype.fire_\",\"unscheduleError_\",\"unhandledException\",\"isNewlyBlocked\",\"length\",\"sequenceEntry\",\"shift\",\"scope\",\"ret\",\"isImplementedBy\",\"global\",\"ex\",\"onCallback\",\"onErrback\",\"STRICT_ERRORS\",\"scheduleError_\",\"succeed\",\"goog.async.Deferred.succeed\",\"fromPromise\",\"goog.async.Deferred.fromPromise\",\"value\",\"fail\",\"goog.async.Deferred.fail\",\"canceled\",\"goog.async.Deferred.canceled\",\"when\",\"goog.async.Deferred.when\",\"goog.async.Deferred.AlreadyCalledError\",\"deferred\",\"debug\",\"inherits\",\"message\",\"name\",\"goog.async.Deferred.CanceledError\",\"Error_\",\"goog.async.Deferred.Error_\",\"id_\",\"setTimeout\",\"throwError\",\"error_\",\"goog.async.Deferred.Error_.prototype.throwError\",\"errorMap_\",\"resetTimer\",\"goog.async.Deferred.Error_.prototype.resetTimer\",\"clearTimeout\",\"goog.async.Deferred.scheduleError_\",\"deferredError\",\"goog.async.Deferred.unscheduleError_\",\"id\",\"assertNoErrors\",\"goog.async.Deferred.assertNoErrors\",\"map\",\"key\"]\n}\n"]